# 컴퓨터 구조

<br>

### 논리연산자

* 순서 :  NOT => AND => OR
  * 연산자 우선 순위는 산술, 관계, 논리 연산 순서

* AND
  * 특정 비트를 Clear 시킬 때 사용
  * **Masking**

* OR
  * 특정 비트를 1로 설정
  * **Selective Set**

* XOR
  * 특정 비트를 반전(**부분 반전**)
  * **Compare**

* NOT
  * 단항 연산으로 **모든 비트**를 반전(1의 보수)
  * **Complement**

* 논리 Shift
  * 빈자리를 0으로 채우는 연산
  * 데이터의 직렬 전송에 사용

* Rotate Shift
  * 빈자리를 빠져나간 비트로 채우는 연산

* 산술 Shift
  * 왼쪽 쉬프트를 n번 하면 2의 n승을 곱한 결과
  * 오른쪽 쉬프트를 n번 하면 2의 n승으로 나눈 결과


---

### 순차회로

* 외부로부터의 **입력과 현재 상태**에 따라 출력이 결정되는 회로
* **기억소자**가 존재

* 플립플롭, 카운터, 레지스터, RAM, CPU

**래치**

* 전자공학에서 1 비트의 정보를 보관, 유지할 수 있는 회로이며 순차 회로의 기본요소

* 순차논리 회로에 사용되는 기억소자로서 입력 신호가 인가되는 순간 바로 출력에 반영이 되도록 하는 소자를 말한다. 
* 즉, Latch는 Clock신호와 무관하게 출력이 결정되는 소자로서 **Asynchronous(비 동기식**)이라고 한다. 
* 반면, Flip Flop은 Clock신호에 맞추어서 rhythmical 하게 출력이 결정되기 때문에 **Synchronous(동기식)** 이라고 한다.

**D 플립플롭**

|  D   | Q(t+1) |
| :--: | :----: |
|  0   |   0    |
|  1   |   1    |

* 래치와 달리 클럭에 반응하여 출력의 변화
* 다음 클럭 활성화까지 출력이 지연되는 특성 -> 버퍼에 활용
* RS플립플롭의 변형으로 R과 S를 인버터(NOT)로 연결하여 전환한 것

**JK 플립플롭**

|  J   |  K   | Q(t+1) |
| :--: | :--: | :----: |
|  0   |  0   |   Q    |
|  0   |  1   |   0    |
|  1   |  0   |   1    |
|  1   |  1   |   Q'   |

<br>

### 카운터(계수기)

* 카운터는 동기식과 비동기식 카운터로 나뉘는데, 비동기식 카운터는 리플 카운터라고도 한다.
* 카운터는 순차 회로이며, 고정된 상태 시퀀스를 순환한다. (0~111까지 세고 다시 0으로 초기화)
* **n-bit 카운터**는 **n개의 플립플롭**을 가지며, **최대 2<sup>n</sup>개의 상태**를 순환한다.
* 계수란 구별되는 상태의 수를 말한다. 즉 위의 2<sup>n</sup>개가 n-bit 카운터의 계수라고 할 수 있다.

**리플 카운터(비동기)**

* 리플 카운터의 Reset 신호는 모든 출력을 0으로 초기화한다. 카운트 신호는 저레벨의 플립플롭의 출력을 토글하는데, 저레벨 플립플롭은 고레벨 플립플롭에 신호를 제공한다.
  * 각 FF를 통과할 때마다 지연시간이 누적됨(고속동작 불가)
  * 동작 및 논리회로 구성이 단순하고, 구현이 용이하다.
* 상향 카운터
  * 4비트 상향 카운터라면 0~15까지 상향
* 하향 카운터

**동기 카운터**

* 동기 카운터는 평행 카운터라고도 한다. 신호가 저레벨에서 고레벨 플립플롭으로 전파되는 비동기 카운터와 달리, 동기 카운터에서는 모든 플립플롭이 동시에 변화한다.
  * 즉, Clock Pulse에 모든 FF가 동시에(병렬로) 동기화되어 동작한다.
* 플립플롭의 입력이 0이면 값을 유지하고 1이면 토글되는, 상승 엣지에 변화하는 모습을 보인다. 
* 컴퓨터 시스템의 대부분의 카운터는 동기 카운터이다.
* 2비트 2진 카운터
  * 00 - 01 - 10 - 00
* 4비트 2진 카운터
  * 0000 - 0001 - 0010 - 0011 - ... - 1110 - 1111

<br>

*Diff?* 비동기 카운터는 모든 회로가 순차적으로 연결되고 연산되니까 지연이 존재. 하지만 동기 카운터의 경우 세번째 자리가 0이되고 네번째 자리가 1이되고 이런게 가능하다.

---

### 조합회로

* 논리 게이트로 구성되며 기억회로는 가지고 있지 않기 때문에 이전 입력과 관계없이 **현재의 입력 조합**으로부터 출력 값이 결정된다

* 반가산기, 전가산기, 디코더, 인코더, 멀티플렉서, 디멀티플렉서

**반가산기**

* A = B = 1, CARRY = 1

![image](https://user-images.githubusercontent.com/75229881/115542007-c369e780-a2da-11eb-8700-7d8ba57a0d25.png)

**반감산기**

![image](https://user-images.githubusercontent.com/75229881/115542053-d2e93080-a2da-11eb-92c2-474516c3cfd5.png)

**전가산기**

* 두 개의 반가산기와 하나의 OR로 구성

**인코더**

* 2<sup>n</sup> 개의 입력과 n개의 출력

**디코더**

* n개의 입력과 2<sup>n</sup> 개의 출력

**멀티플렉서**

* 여러 입력 신호 중 하나를 선택해서 출력

**디멀티플렉서**

* 하나의 입력 신호를 여러개의 출력 신호중 하나로 출력

---

### 제어장치

>  프로세서의 조작을 지시하는 컴퓨터 중앙 처리 장치(CPU)의 한 부품이다. 
>
> 입출력 장치 간 통신 및 조율을 제어한다. 명령어들을 읽고 해석하며 데이터 처리를 위한 시퀀스를 결정한다.

**제어장치의 구성**

![image](https://user-images.githubusercontent.com/75229881/170475186-fe3cb362-202e-496d-849b-894cc00408f1.png)

- 명령 레지스터(IR)
  - 현재 실행중인 명령어를 기억
- 인코더(Encoder)
  - '제어신호 발생기', '부호기'
  - 해독된 명령에 따라 각 장치로 보낼 제어 신호를 생성
- 디코더(Decoder)
  - '명령 해독기'
  - 명령 레지스터에 있는 명령어를 해독
- 메모리 버퍼 레지스터(MBR)
  - 기억장치에 입출력되는 데이터의 주소 번지를 기억
- 제어 주소 레지스터(CAR)
  - 다음에 실행할 마이크로 명령어 주소를 저장
  - Mapping 결과값, 주소 필드, 서브루틴 레지스터 내용 적재
- 제어 버퍼 레지스터(CBR)
  - 제어 기억장치로부터 읽혀진 마이크로 명령어 비트들을 일시적으로 저장
- 제어 기억장치
  - 마이크로 프로그램을 저장
- 프로그램 카운터(PC)
  - 다음번에 실행할 명령어의 번지를 기억
- 순서 제어 모듈
  - 마이크로 명령어의 실행 순서를 결정
- 순차 카운터(Sequence Counter)
  - 디코더에 의해 선택된 번호에 해당하는 타이밍 신호(Clock)를 생성

<br>

**제어방식**

![image](https://user-images.githubusercontent.com/75229881/170474101-3691029b-c1df-49a5-8595-af1662f11a50.png)

* Hard-Wired
  * 회로도가 복잡하고 구현 비용이 많이 들어간다.
  * 제어 메모리가 필요 없으며 속도가 빠르다.
  * 명령어 교체를 위해 하드웨어를 교체해야 함.
* Micro Programming
  * 마이크로 프로그램이 저장된 별도의 제어 메모리를 필요로 한다.
  * 속도가 상대적으로 느리다.

<br>

**참고자료**

* 메모리 용량
  * 2<sup>MAR</sup> * MBR
  * MAR = PC = Address Bus
  * MBR = Data Bus = Word Size

---

### 레지스터

**제어 레지스터**

| 플래그 기호 |       이름        |                             의미                             |
| :---------: | :---------------: | :----------------------------------------------------------: |
|      Z      |    제로 플래그    |              연산 결과가 0일 경우에 참이 된다.               |
|      C      |    캐리 플래그    | 부호 없는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 참이 된다. |
|      A      | 보조 캐리 플래그  | 연산 결과 하위 니블(4bits)에서 비트 범위를 넘어섰을 때 참이 된다. <br>이진화 십진법(BCD) 연산에 사용된다. |
|     OV      |  오버플로 플래그  | 부호 있는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 참이 된다. |
|     NS      |    사인 플래그    |               연산 결과가 음수일 때 참이 된다.               |
|     IE      |  인터럽트 플래그  | 이 플래그가 참(1)일 경우에만 인터럽트 요구를 받아들인다. <br>일반적으로 관리자 모드에서만 값을 변경 할 수 있다. |
|      P      |   패리티 플래그   |    연산 결과에서 1로된 비트의 수가 짝수일 경우 참이 된다.    |
|      D      |   디렉션 플래그   | 문자열 조작에서 참일 경우 주소 레지스터 값이 자동으로 감소하고, 거짓일 경우 자동으로 증가한다. |
|      T      |    트랩 플래그    | 참일 경우 한 명령이 실행할 때마다 인터럽트가 발생한다. <br>디버깅에 사용된다. |
|     SV      | 슈퍼바이저 플래그 | CPU가 운영체제 모드와 사용자 모드 중 어느 모드에서 프로그램을 실행 중인가를 나타냄<br>특권 명령어(privilege instructions)는 운영체제 모드에서만 실행 |



---

### 버스

```
버스대역폭 = 버스의 클럭 주파수 X 데이터 버스의 폭
ex) 
버스의 클록 주파수가 100Mhz이고 데이터 버스의 폭이 32Bit(4Byte)
-> 400 MByte/sec
```

**시스템버스**

* 주소버스
  * 메모리의 주소나 I/O Unit의 포트 번호를 전달
* 제어버스
  * Read와 Write신호가 전달
* 데이터버스
  * 각 구성요소(CPU, Memory, I/O Unit)는 양방향으로 데이터 전달이 가능한 버스

**I/O 버스**

---

### 중재 버스

> 버스 중재는 버스 중재기라는 하드웨어에 의해 실행된다. 
>
> 중재 방식은 다음과 같이 두 가지 기준에 따라 분류된다.

* 버스 마스터와 버스 중재기 간 연결 구조에 따른 분류
  * 병렬 중재 방식
    * 각 버스 마스터가 독립적으로 버스 요구/승인 신호를 주고 받는다. 따라서 버스 마스터의 수 만큼 버스 요구/승인 선이 필요하고 회로가 비교적 복잡하다. 각 버스 마스터의 우선순위에 따라 고정-우선순위 방식과 가변-우선순위 방식으로 구분된다.
  * 직렬 중재 방식
    * 하나의 버스 요구/승인 선이 존재하며 각 신호 선을 버스 마스터들 간에 직렬로 연결(데이지 체인)한다. 회로가 비교적 간단하지만, 결함에 취약하며 기아 문제가 발생할 수 있다.

* 버스 중재기의 위치 및 개수에 따른 분류
  * 중앙집중식 
    * 중재 방식시스템 내에 단 하나의 버스 중재기가 존재한다. 모든 버스 신호 선은 이 중재기에 연결된다.
  * 분산식 중재 방식
    * 시스템 내에 여러 버스 중재기가 존재한다(일반적으로 각 버스 마스터가 버스 중재기를 가지는 구조)

<br>

**버스 중재 방식**

* 중앙집중식 병렬 중재 방식 (고정-우선순위)
  * 버스 마스터가 버스 중재기와 가까울수록 높은 우선순위를 가진다.
* 분산식 병렬 중재 방식 (고정-우선순위)
  * 각 버스 중재기는 자신보다 우선순위가 높은 버스 마스터들이 모두 사용 요구를 하지 않을 때 자신의 버스 마스터로 버스 승인 신호를 발생한다. 
  * 이는 중앙집중식에 비해 회로가 간단하고 동작 속도가 빠를 수 있지만, 버스 중재기에 오류가 발생하면 해당 버스 중재기를 찾아내기 힘들고, 이 오류가 시스템 전반에 영향을 줄 수 있다.
* 병렬 중재 방식 (가변-우선순위 방식)
  * 모든 버스 마스터가 비교적 공정하게 버스를 사용할 수 있다. 
  * 버스 마스터의 우선순위는 다양한 방식으로 변경될 수 있는데 방식에 따라 회로가 매우 복잡해질 수도 있다.
* 중앙집중식 직렬 중재 방식
  * 하나 이상의 버스 마스터가 공통 선에 버스 사용을 요구하면, 버스 중재기는 첫 번째로 연결된 버스 마스터로 승인 신호를 전송한다. 
  * 만약 해당 버스 마스터가 버스 사용을 요구하지 않았다면 이 신호는 다음 버스 마스터로 전달된다. 
  * 버스마스터가 직렬 연결이기 때문에 우선순위는 고정된다.
* 분산식 직렬 중재 방식
  * 버스 중재기는 순환형으로 연결된다. 
  * 버스 중재기가 승인 신호를 전송하면 중앙집중식 직렬 중재 방식처럼 이 신호는 버스 사용을 요구한 버스 마스터까지 전달된다. 
  * 이 순환형 연결 방식에서는 각 버스 마스터의 우선순위가 계속 변화한다. 하지만 어느 한 지점에 결함이 발생하면 시스템 전체가 동작을 멈추게 된다.

---

### 인터럽트

**동기 인터럽트**

* 명령어 실행 중 CPU에 의해 처리되는 인터럽트로 하나의 명령어가 종료 후 인터럽트가 발생한다. 
* EX
  * 0으로 나누기
  * 프로세스 내 명령어 실행에 의한 발생하는 인터럽트
  * 프로세스 내 명령어가 보호 메모리영역을 참조할 때 발생하는 인터럽트

**비동기 인터럽트**

* 다른 하드웨어 장치가 CPU 클럭시 시그널과 상관없이 생성하는 인터럽트이다. 키보드 혹은 마우스를 사용할 때 발생하는 것과 같은 인터럽트를 말한다.

---

### 폴링

> 폴링과 인터럽트는 결국 CPU와 입출력 장치의 통신 방식
>
> 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행

* 하드웨어 폴링
  * 버스 중재기와 각 버스 마스터 간 별도의 폴링 선을 연결한다(이때 이진화된 폴링 주소를 사용하면 폴링 선의 수를 log개로 줄일 수 있다.). 
  * 버스 중재기는 이 폴링선을 검사하고, 검사 순서에 따라 버스 마스터의 우선순위가 결정된다.
* 소프트웨어 폴링
  * 버스 중재기 내의 프로세서가 폴링의 순서와 과정을 관장한다. 
  * 하드웨어 방식에 비해 속도가 느리지만 폴링 순서(버스 마스터의 우선순위)의 변경이 쉽다.

---

### 운영체제의 발달과정

|     시스템     |                                                              |
| :------------: | :----------------------------------------------------------- |
|    일괄처리    | 초기 컴퓨터 시스템으로, 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식<br>사용자 측면에서 반환(응답)시간이 늦지만 하나의 작업이 모든 자원을 독점하므로 CPU 유휴시간이 줄어듦 |
| 다중프로그래밍 | **하나의 CPU**와 **주기억장치**를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식 |
|     시분할     | 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아 가며 처리<br>라운드 로빈(Round Robin) 방식 |
|    다중처리    | **여러개의 CPU**와 **하나의 주기억장치**를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식 |
|   실시간처리   | 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식 |
|  다중모드처리  | 일괄 처리 시스템, 시분할 시스템, 다중 처리 시스템, 실시간 처리 시스템을<br> 한 시스템에서 모두 제공하는 방식 |
|    분산처리    | 여러개의 컴퓨터(프로세서)를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식<br>각 컴퓨터 시스템은 고유의 운영체제와 CPU, 메모리를 가지고 있음 |

---

### Flynn의 분류

* SISD
  * 단일 명령어 / 단일 데이터 흐름
  * 파이프라이닝과 슈퍼스칼라(파이프라인x2)를 이용하여 병렬처리
* SIMD
  * 단일 명령어 / 다중 데이터 흐름
  * 배열 프로세서
  * CUDA처럼 동시에 배열을 한번에 찍어내는 연산
* MISD
  * 실제 구현X
  * 다중 명령어 / 단일 데이터 흐름
* MIMD
  * 다중 처리기
  * 다중 명령어 / 다중 데이터 흐름

---

### 병렬처리 종류

* 파이프라인
  * Fetch, Decode, Execute, Write-back(결과값 쓰기) 등의 각기 다른 작업의 명령을 한 클럭에 동시에 실행
  * 파이프라이닝은 다수의 브런치나 서브루틴 콜이 발생하면 효율이 떨어지기 때문에 최신 아키텍처는 분기예측 기법을 통해 이런 문제를 회피
    * 분기의 결과를 예측하여 기다리지 않고 파이프라인에 넣음, 틀리면 명령어 삭제
* 슈퍼파이프라인
  * 파이프라인 단계를 더 잘게 쪼개서 병렬성을 더욱 증가
  * 기존 단일 파이프라인과 다르게 몇 가지 동작을 명령어 **수행 과정에서 중첩**하는 기술

* 슈퍼스칼라
  * 파이프라인을 여러 개 두어 병렬성을 극대화
  * 파이프라인이 처리할 수 있는 **코어를 여러 개 구성**

* 슈퍼파이퍼라인 슈퍼스칼라
  * 슈퍼스칼라에 슈퍼 파이프라인 기법을 적용

* VLIW
  * 앞의 병렬 처리 기법은 하드웨어적인 방법이지만 VLIW(Very Long Instruction Word) 기법은 **소프트웨어적으로 병렬 처리**하는 방법
  * VLIW 기법에서 동시에 수행할 수 있는 명령어들을 컴파일러가 추출하고 **하나의 명령어로 압축**하여 실행


**기타**

* 멀티 프로그래밍
  * RAM에 여러 프로세스를 올려서 사용
* 벡터 프로세싱
  *  SIMD를 의미
* 멀티 프로세싱
  * 다중 처리기를 의미

* 실시간 시스템
  * 프로그램 동작의 실시간성 및 데드라인이 중요함
* 시분할 시스템
  * RR, 타임슬라이스 등 활용

---

### 다중 처리기(Multi-Processor)

* Master/Slave 처리기
  * Master : 입출력, 연산, OS
  * Slave : 연산
* 분리 실행 처리기
  * 각 프로세서가 독자적인 OS 보유
  * 할당된 작업은 해당 프로세서가 모두 처리해야 되기 때문에 한 프로세서에 일이 밀려도 다른 프로세서는 유휴 상태가 될 수 있다.
* 대칭적 처리기
  * 분리 실행 처리기 구조의 문제점을 보완한 것으로, 여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조이다.
  * 프로세서 간의 통신은 공유 메모리를 통해 이루어진다.

![image](https://user-images.githubusercontent.com/75229881/168795055-8544b0d4-8fd3-4e20-8fe6-a3c29172f6b7.png)

* **Systolic Array**

  * Systolic이란 “혈관을 흐르는”이라는 뜻을 가진 단어인데, 혈관이 우리 몸의 세포를 지나가듯 데이터가 연산을 담당하는 Processing unit을 지나간다는 의미
  * 이는 데이터의 재사용율을 높이기 위한 구조인데요, 재사용율이란 메모리로부터 가져온 데이터를 얼마나 반복하여 연산하는가를 의미합니다. 데이터 재사용율은 딥러닝 연산에서 매우 중요합니다. 데이터를 DRAM으로부터 가져오는 긴 시간(Latency) 동안 Processor는 쉬어야 하기 때문에 동일 시간에 수행할 수 있는 작업량이 줄어듭니다. 
  * 또한 DRAM으로부터 데이터 가져오는 작업은 에너지를 많이 소모하죠. 따라서 딥러닝 Accelerator 설계자 입장에서는 DRAM에서 가져온 데이터를 최대한 많이 사용하고자 합니다
  * Matrix multiplication unit에서는 딥러닝 model data (weight)가 위에서 아래로, Feature map등 화면 data는 좌에서 우로 흘러가고 최대 256번까지 연산됩니다. 데이터가 각 Processing unit을 지나가면서 1번의 곱셈과 덧셈 연산을 하게 되죠. Matrix multiply unit의 왼쪽을 보면 “Systolic data setup”이라는 블록이 있는데 위에서 내려오는 딥러닝 모델의 Weight에 맞춰 연산을 수행하기 위해 중간 결과값(Feature map)을 스케쥴링하는 역할을 합니다. Systolic array 방식으로 한번에 약 5만번의 계산을 수행하는 연산 장치를 효율적으로 활용하기 위한 블록이죠.

  ```
  명령어를 실행할 때, 행할 명령어의 순서와 상관없이 단지 피연산자가 준비되기만 하면 수행되여 Program Counter가 필요없는 컴퓨터 구조
  ```

<br>

**프로세서 결합도**

* **강결합 시스템(병렬처리 시스템)**

  * **CPU들**을 **네트워크로 상호 연결**하여, 전체적인 일의 부분 부분을 나누어 더 빨리 처리하는 방식이다.

  * 여러 CPU와 하나의 공유 메모리 구조

  * 복잡하고 결합력이 강함

  * 프로세서 추가해도 성능향상이 없음

  * **CAP 이론** : 분산시스템은 3개 속성을 모두 가지는 것이 불가능하다는 특징을 갖는다.

    > **관계형 데이터베이스는 CA 시스템이다. **
    >
    > **일관성(C)와 가용성(A)를 보장하지만, 분리 내구성(P)은 보장하지 않는다**

    * Consistency (일관성)
      - 데이터는 항상 일관성 있는 상태를 유지해야 한다.
      - 데이터의 조작 이후에도 무결성을 해치지 않아야 한다.
      - 모든 노드가 **같은 시간**에 **같은 데이터**를 보여줘야 한다.
    * Availability (가용성)
      - 특정 노드에 장애가 발생하더라도 서비스는 가능해야 한다.
      - 데이터 저장소에 대한 모든 동작(read, write 등)은 항상 성공적으로 리턴되어야 한다.
    * Partitions Tolerance (분리 내구성)
      - 노드 간에 통신 문제가 발생하여 메시지를 주고받지 못하는 상황이더라도 서비스는 가능해야 한다.
      - Availability의 경우는 특정 노드에 "장애"가 발생한 상황에 대한 것이고, Partitions Tolerance의 경우는 노드는 정상이지만 네트워크에 문제가 발생하여 연결이 끊어지는 상황이라는 점에서 차이점이 있다.

* **약결합 시스템(분산처리 시스템)**
  
  * 분산 처리기, 여러 OS가 처리
  * 독자적인 메모리를 가짐
  * 프로세서간 통신은 메시지 혹은 원격 프로시저를 호출

---

### 다중 처리기 연결방식

* 하이퍼큐브

  ![image](https://user-images.githubusercontent.com/75229881/116369782-b8680780-a844-11eb-9f83-e1622d0230e1.png)

  * 분산기억장치 시스템
  * 연결점이 n이면 2<sup>n</sup>개의 CPU 존재
  * 경제적이고 확장성이 좋음

* 시분할 및 공유버스

  ![image](https://user-images.githubusercontent.com/75229881/116370002-f06f4a80-a844-11eb-906b-19f3ebf18605.png)

  * 프로세서, 주변장치, 주기억장치 등을 단일 버스로 연결
  * 장치 추가가 용이하며 한 시점에 한 번의 전송만이 가능

* 크로스바 교환 행렬

  ![image](https://user-images.githubusercontent.com/75229881/116370134-0ed54600-a845-11eb-820d-c6f6d55577c5.png)

  * 버스의 수를 메모리의 수 만큼 증가
  * 기억장치의 동시참조 가능

* 다중 포트 기억장치

  

  <img src = "https://user-images.githubusercontent.com/75229881/116370297-362c1300-a845-11eb-9638-3f1a9d903f39.png" width="50%">

  * 시분할 및 공유 버스 기법 + 크로스바 교환 행렬
  * 다양한 연결이 가능하지만 전송시간이 느리다.

---

### SMT(Simultaneous Multi-Threading)

* 하이퍼스레딩
* 하나의 코어에 여러 스레드를 올려서 사용하는 기법
* 동시에 처리할 수 있는 명령들을 1개의 코어가 동시에 작업한다
* sw적으로 코어가 두개처럼 보인다

---

### 파이프라이닝 해저드

* 구조 해저드
  * 명령어가 사용하는 자원의 충돌이 발생하지만 구조적으로 하드웨어가 지원해 줄 수 있는 자원이 없는 경우 발생. 즉, 파이프라인에서 **동일명령이 발생하지만 H/W는 하나의 명령만을 처리**할 수 있는 구조일 때 발생 
  * 부족한 자원의 추가로 해결
* 데이터 해저드
  * 앞의 명령어에서 완전히 write를 끝내기 전에 다음 명령어가 read 하는 것처럼 **명령어 사이에 종속성**이 존재할 경우. 즉, **실행되지 않은 결과가 필요**할 때 발생
  * **데이터 포워딩**을 통해 해결, **별도의 하드웨어**를 추가 하여 정상적으로는 얻을 수 없는 값을 내부 자원으로부터 일찍 받아오는 것
* 제어 해저드
  * 앞서 분기 명령어에 의해 필요없는 명령어가 실행되는 경우. IF가 실행되면 Else 명령어들은 필요없어짐
  * **분기 예측**을 통해 해결

---

### 마이크로 오퍼레이션

```
Instruction Cycle Code,
00 : Fetch Cycle 
01 : Indirect Cycle 
10 : Execute Cycle 
11 : Interrupt Cycle 
```

* Fetch
  * t1 : MAR <- PC
    * 명령어가 저장된 주소를 MAR로 전송
    * **주소버스**를 통해 주소를 전달받고 **제어버스**를 통해 Read 명령을 실행
  * t2 : MBR <- M[MAR], PC <- PC+1
    * 메모리에서 명령어를 인출하여 MBR로 전송
    * **데이터버스**를 통해 메모리에 저장된 데이터를 반환
  * t3 : IR <- MBR
    * 명령어 디코딩을 위해 MBR의 데이터를 IR로 전송 및 PC는 다음 주소를 가리킴
    * 이후 IR에서 명령어 디코딩 및 실행하여 **제어버스**를 통해 제어신호를 전달
* Indirect
  * t1 : MAR <- IR[Address]
  * t2 : MBR <- M[MAR]
  * t3 : IR[Address] <- MBR[Address]
* Execute
  * ADD R, X (레지스터 R에 X의 내용을 더하라)
  * t1 : MAR <- IR[Address]
  * t2 : MBR <- M[MAR]
  * t3 : R <- R + MBR
* Interrupt
  * t1 : MBR <- PC
  * t2 : MAR <- Save Address, PC <- Routine Address
  * t3 : M[MAR] <- MBR

---

### Instruction Set

**Instruction**

* Opcode + Operand 구성
  * **3 + 6 = 9** 라는 연산이 있을 때 '+' 이 **Opcode** 이고 3, 6 이 **Operand**

**Number of Address**

* 3 주소
  * Operand1, Operand2, Operand3(Result) 로 구성
  * A = B + C
* 2 주소
  * A = A + B
* 1 주소
  * AC <- A
* 0 주소
  * 주소가 필요없는 명령, 스택을 활용한다.
  * PUSH A

**Addressing Mode**

>Instruction Fetch 되어 있기 때문에 명령어는 CPU에 있다. 
>
>그리고 대부분의 데이터는 memory에 있다

**메모리 접근**

* Immediate Addressing
  * 데이터가 Memory에 있는게 아니라 명령어 안에 있는 것
    * ADD 5 (Operand안에 5라는 **데이터**가 있음)
* Direct Addressing
  * Operand에 Memory의 주소가 있음
  * EA(Effective address) = A
* Indirect Addressing
  * 메모리에 데이터의 포인터
  * EA = (A)

**레지스터 접근**

* Register Addressing
  * 메모리 참조 필요없음 / 주소 제한적(레지스터 몇개 없음)
  * EA = R
* Register Indirect Addressing
  * 레지스터에 데이터의 포인터 / 메모리 참조 
  * EA = (R)

**Displacement Addressing(변위주소)**

> EA = A + (R)의 형태

* **Relative addressing**
  * 변위정보는 PC 값
  * 프로그램 카운터는 알아서 increment를 해주는 특징이 있다. 32 비트면 4만큼 64비트면 8만큼 increment한다. 
  * 알아서 increment를 시켜주니 Relative Addressing이라고 한다.
  * EA = A + (PC)
* **Base-Register addressing** 
  * 변위정보는 A
  * EA = A + (R)
* **Indexing Addressing** 
  * 변위정보는 레지스터
  * EA = A + (R)

---

### 부울대수

1. x(y + z) = xy + xz
2. **x + yz = (x + y)(x + z)**
3. (x + y)' = x'y'
4. (xy)' = x' + y'
5.  **A+AB=A**

---

### 암달의 법칙

- f : 전체 시스템 시간에서 개선된 부분이 차지하고 있는 시간의 비율
- S : 성능이 몇 배 향상됐는지.

$$
latency(S) = {1\over(1-f)+{f\over s}}
$$

---

### 유니버셜 게이트

> 범용게이트라고 부른다

* Universal gate는 한 종류만으로 모든 boolean expression을 구현할 수 있는 게이트를 말한다
* 종류
  * NOR, NAND
  * MUX
  * OR + Decoder

---

### XNOR

![image](https://user-images.githubusercontent.com/75229881/154259818-e0852eb9-6199-4dba-8ecc-20ff1f2daef6.png)

![image](https://user-images.githubusercontent.com/75229881/154259863-7fb6a27a-1ad2-4e9c-916d-f6b78b256136.png)

* XNOR 게이트는 ’1‘ 상태로 입력되는 입력 단자의 수가 짝수 개이면 출력이 ’1‘이 되고 그렇지 않으면 ’0‘이 된다.

---

