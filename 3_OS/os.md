# Operation System

<br>

### 디스크 스케줄링

* FCFS

* SSTF 

* SCAN

  * 좌우 왕복하면서 가는 길에 처리한다

  ![image](https://user-images.githubusercontent.com/75229881/110737022-fa76c300-826f-11eb-960a-27499f930912.png)

  > N-step-SCAN
  >
  > 디스크 헤더가 n개의 요청만 받아들이고 이들만 수행한다
  >
  > 만약 n이 엄청 큰 숫자이면 SCAN과 다를게 없고, n이 1이면 FCFS와 다를게 없다
  >
  > *response-time-interval*을 줄일 수 있다

* C-SCAN

  * 한 쪽 방향으로만 이동한다

  ![image](https://user-images.githubusercontent.com/75229881/110737211-4a558a00-8270-11eb-896a-7a7f71f22823.png)

* LOOK/C-LOOK

  * 끝까지는 안간다

  ![image](https://user-images.githubusercontent.com/75229881/110737261-63f6d180-8270-11eb-8cbf-d2e8dff088c7.png)

---

### 제어장치의 구성요소
* 명령 계수기(PC) 
  * 다음에 실행할 명령의 주소기억
* 주소 레지스터(MAR)
  * 주기억장치에 선택될 주소를 기억하는 레지스터
* 내용 레지스터(MBR)
  * PC나 MAR이 지정하는 주기억장치의 내용을 임시로 기억하는 레지스터 
* 명령 레지스터(IR)
  * PC가 지정한 주소의 명령을 인출하여 명령 실행이 완료될 때 까지 명령을 보관하는 레지스터 
* 명령 해독기
  * IR에서 보내온 명령 코드를 해독
* 인덱스 레지스터(IX)
  * 명령 어드레스나 인덱스를 변경할 때 사용
* 제어신호 발생기(부호기)
  * 명령 해독기에서 보내온 신호를 명령을 실행하는데 필요한 신호로 바꾸어 각 장치에 제어신호 전송

---

### 페이징

*  프로세스의 물리 주소 공간이 연속되지 않아도 되는 메모리 관리 기법
* 물리페이지는 frame, 논리메모리는 page로 분할된다
* 예제
  * 페이지 크기는 2000byte
  * 논리주소가 2500이면 페이지번호는 1번임, 이에 해당하는 프레임번호가 3번, 오프셋은 500
  * 물리주소는 6500
* 페이징 자체는 일종의 동적 재배치

---

### 단편화

* 내부단편화
* 외부단편화
  * 세그먼테이션 사용 시, 남은 메모리 공간은 충분한 공간이 있으나 조각나서 할당이 불가한 상태 

---

### RAID

* RAID 0 (스트라이핑)
  * 읽기/쓰기 n배 상향
  * 디스크 수 * Disk 용량
  * 낮은 안정성
* RAID 1 (미러링)
  * 읽기 n배 상향, 쓰기 시 성능 감소
  * 디스크 수 /2 * 용량
  * 높은 안정성
* RAID 2
  * 해밍코드
* RAID 3/4
  * 데이터 스트라이핑 및 별도의 Parity disk 사용
  * 3 - byte 단위 / 4 - block 단위
* RAID 5
  *  Block 레벨의 Striping과 Parity 사용(Parity 분산 제공)
  * 읽기 N배, 쓰기 성능이 (N-1)배 향상
* RAID 6
  *  Block 레벨의 Striping과 Double Parity 사용(Parity 분산 제공)
  * 읽기 N배, 쓰기 성능이 (N-2)배 향상

---

### 프로세스 스케줄링

**비선점**

* FCFS
* SJF
  * 실행시간이 짧은 스케줄 먼저 실행
* HRN
  * (대기시간 + 실행시간) / 실행시간으로 우선순위를 결정, 높을수록 우선순위가 높음

**선점**

* RR
  * 각 프로세스마다 동일한 실행시간 부여
  * Clock 인터럽트를 필요로 한다.
* SRT
  * SJF와 비슷하나 짧은 스케줄이 들어왔을 때 선점가능
  * **큐에 새로운 프로세스가 들어왔을 때**, 실행중인 프로세스와 대기중인 프로세스의 실행시간을 비교
* Multi-Level Queue
  * 여러 큐를 형성하여 높은 우선순위의 큐에 있는 작업이 우선순위를 가진다.
* Multi-Level Feedback Queue
  * 각 큐에 time-quantum을 적용하여 실행시간이 길어지면 아래 큐로 보낸다.
  * 보통 밑으로 갈수록 time이 길고 마지막에는 FCFS로 처리

---

### 페이지 교체 기법

* FIFO
* OPT
  * 앞으로 가장 사용되지 않을 페이지 교체
* LRU
* LFU
  * 참조비트 사용
* NUR
  * 참조비트와 변형비트를 사용
  * 변형비트는 페이지가 수정되었을 때 1로 set
  * 참조비트가 변형비트보다 우선순위가 높다
* SCR(Second-Chance Replacement)
  * FIFO에서 참조된 페이지는 Reference bit을 1로 설정하고 만약 1일 때, 교체대상이라면 0으로 설정하고 한 번의 기회를 부여

---

### CISC/RISC

**CISC**

* 명령어의 개수가 다양하며 길이는 가변적
* 고급언어에 대해 각각 기계어가 대응되도록 하는 것, 복잡한 구조를 가진다.
* 복잡한 컴파일러, 회로구성 복잡
* 복잡한 명령이 많기 때문에 마이크로 프로그램으로 제어한다.

**RISC**

* 명령어의 개수가 적으며 고정 길이를 가진다.
* 단순한 컴파일러, 회로구성 단순
* 단순 명령이 많기 때문에 다수의 레지스터가 필요하고 하드와이어(Hard-wired)방식으로 제어한다.

---

### 프로세스 상태전이

![process_state](https://user-images.githubusercontent.com/75229881/113966976-0ce21d80-986b-11eb-9bf5-e879ae14dc4d.png)

* 상태전이
  * Dispatch - 프로세스 스케줄러에 의해 결정된 우선순위에 따라 프로세스가 CPU를 점유하게 되는 상태
  * Time out - 프로세스가 실행중이다가 제한된 시간을 다 소비하여 CPU 점유를 빼앗기는 상태
  * Block - 실행중이던 프로세스가 외부 요인에 의해서 자원을 빼앗기는 상태
  * Wake up - 프로세스가 자원을 할당받는 상태
  * Swap in - 프로세스가 주기억장치에 적재 되는 상태
  * Swap out - 프로세스가 주기억장치에서 해제 되는 상태
* Ready 상태로의 전이
  * Running에서 Time-out
  * Asleep(I/O등의 이유로 Block됨)에서 Wake-up
  * 우선순위에 의하여 선점당했을 때

---

### 캐시

* 블록
  * 주기억장치에서 word를 나누는 단위
  * 주기억장치 용량이 2<sup>n</sup> word이고 블록 사이즈가 K word라면 블록의 수는 2<sup>n</sup>/K
* 라인
  * 캐시의 크기만큼의 라인을 가짐
  * 주기억 장치가 64 word 이고 캐시가 16 word라면 4 line을 가진다.
* 태그
  * 블록 내부의 offset

<br>

**매핑방식**

![image](https://user-images.githubusercontent.com/75229881/114500782-bb1f0600-9c63-11eb-9a73-416a15fb779a.png)

* 직접사상

  * 태그 필드에서 해당 블록의 위치를 지정
  * 라인 필드에서 라인을 지정(블록크기와 동일)
  * 단어 필드(데이터)

![image](https://user-images.githubusercontent.com/75229881/114502916-79905a00-9c67-11eb-89c9-96e026cac12c.png)

* 연관사상

  * 블록으로 안나누고 태그가 하나의 Word의 주소를 가진다

![image](https://user-images.githubusercontent.com/75229881/114503120-c2e0a980-9c67-11eb-8a12-da0b01bf4837.png)

* 세트-연관 사상

  * 세트는 블록의 묶음(2-way면 2라인을 가진다)
  * (t+d) 비트가 주기억장치의 2<sup>(t+d)</sup>를 가리킨다

```
만약 캐시 메모리 크기가 64Kb이고 캐시 블록의 크기가 32byte이다.
그리고 4-way 집합연관 사상한다면
블록의 크기는 2의 11승이 되고 이를 4개의 라인으로 나누기 때문에 총 512개의 set이 생성된다
```
**저장방식**

* Write-through
  * 캐시와 메모리 동시에 저장
  * 데이터 불일치 문제가 없지만 속도느려짐
* Write-back
  * 캐시에 적재 후 캐시에서 버릴 때, 메모리에 저장하는 방식
  * 데이터 불일치(캐시와 메모리 값이 다름)

**지역성**

* Hit Ratio를 높이기 위해서는 데이터의 지역성을 가져야 한다. 즉, 데이터 접근이 시간적, 공간적으로 가깝게 일어나야 한다.
* 시간적 지역성
  * 특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것
  * 메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우
* 공간적 지역성
  * 특정 데이터와 가까운 주소가 순서대로 접근되었을 경우

---

### I-node

**구성**

- 파일 모드
- 소유자명
- 그룹명
- 파일 크기
- 마지막 접근 정보
- 마지막 수정 정보
- i-node 수정 정보

---

### 가상화

> 가상화란 가상화를 관리하는 소프트웨어(주로 Hypervisor)를 사용하여 하나의 물리적 머신에서 가상 머신(VM)을 만드는 프로세스

**Type1 : Native, Bare Metal Hypervisor** 

* Type1 가상화는 VMM(Virtual Machine Monitor)을 하드웨어상에 직접 동작을 시키므로  호스트OS가 필요없다.
* 호스트형 가상화에 비해 오버헤드가 적고 물리 컴퓨터 리소스의 관리가 유연한게 특징
* 자체적인 관리기능이 없어서 하드웨어 가상화 기술 지원을 필요로함(Intel-VT, AMD-V)
* KVM, Xen
* 전가상화(Full Virtualization)

  * 전체 하드웨어를 완전히 가상화하는 기술
  * 게스트 OS가 자신이 가상화 환경인지 모르는 상태를 의미하며, 그에 따라 가상화되지 않은 실제 하드웨어 명령을 직접 요청 하는 것처럼 동작한다.
  * 하이퍼바이저가 모든 요청을 처리해야하기 때문에 비교적 느리다.
* 반가상화(Para Virtualization)

  * 전가상화의 가장큰 단점인 성능저하의 문제를 해결하기 위해 **하이퍼콜(Hyper Call)**이라는 인터페이스를 통해 하이퍼바이저에게 직접 요청을 날릴 수 있다.
  * 하이퍼바이저에게 Hyper Call 요청을 할 수 있도록 각 게스트 OS의 커널을 수정해야함
  * 쉽게 말하면 가상화된 각 OS들이 각각 다른 번역기를 갖고 있는 것

**Type2 : Hosted Hypervisor**

* Host OS위에 Guest OS가 구동되는 방식
* 오버헤드가 크다. 성능이 가장 떨어지는 방식
* 손쉽게 구축가능한 특징
* QEMU, Vmware Workstation

---

### I/O 제어방식

**Programmed I/O**

* 원하는 I/O가 완료되었는지 여부를 검사하기 위해 CPU가 상태 플래그를 계속 조사하여 I/O가 완료된 경우 MDR(MBR)과 AC 사이의 자료 전송을 CPU가 직접 처리하는 방식(**Polling 방식**)
* I/O 작업 시 CPU는 계속 I/O 작업에 관여해야 하기 때문에 다른 작업을 할 수 없음
* 입력의 완료를 알리기 위해 인터럽트가 필요 없는 대신 CPU가 지속적으로 입출력 완료 여부를 확인해야함
* 리소스가 많이 소요되지만 구현이 단순하다,

**Interrupt I/O**

* 데이터를 전송할 준비가 되면 I/O 인터페이스가 컴퓨터에게 알려 입출력이 이루어짐
* I/O 인터페이스는 CPU에게 인터럽트 신호를 보내 입출력이 있음을 알림
* CPU가 지속적으로 Flag를 검사하지 않아도 되기 때문에 Pragrammed I/O보다 효율적
* CPU가 입력을 지시한 후 워드의 입력이 이루어지는 사이 다른 작업(타 프로그램 실행)이 이루어짐

**DMA(Directed Memory Access)**

* 입출력 기기들이 CPU의 레지스터를 거치지 않고 직접 메모리를 엑세스하여 입출력 데이터 전송
* CPU는 I/O에 필요한 정보를 DMA 제어기에 알려 I/O 동작을 개시시킨 후, 다른 작업을 수행
* 입출력 자료 전송 시 CPU를 거치지 않기 때문에 CPU의 부담 없이 빠른 데이터 전송 가능
* DMA의 우선순위는 메모리 참조의 경우 중앙처리장치보다 상대적으로 높음
* 인터럽트 신호를 발생시켜 CPU에게 입출력 종료를 알림
* **Cycle Steal** 방식을 이용하여 데이터 전송 
  * CPU와 DMA 방식의 입출력 장치가 공통된 버스를 통해 주기억장치에 연결된 경우, 우선순위가 높은 입출력 채널이 접근 사이클을 먼저 사용하여 주기억장치에 접근하는 것 >> 작업 효율성 UP, CPU의 양보

**Channel I/O**

* I/O를 위한 특별 명령어를 I/O 프로세스에게 수행토록 하여 CPU 관여없이 주기억장치와 입출력장치 사이에서 입출력을 제어하는 입출력 전용 프로세서(IOP)
* 채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 입출력 동작 처리
* CPU로부터 입출력 전송을 위한 명령어를 받으면 CPU와는 독립적으로 동작하여 입출력 완료
* 채널을 주기억장치에 기억되어 있는 채널 프로그램의 수행과 자료 전송을 위해 주기억장치 직접 접근
* 채널의 종류
  * Selector Channel : 고속 입출력장치(자기디스크, 자기테이프, 자기드럼) 1개와 입출력하기위해 사용
  * Multiplexer Channel : 저속 입출력장치(카드리더, 프린터) 여러개를 동시에 제어하는 채널
  * Block Multiplexer Channel : 동식에 여러 개의 고속 입출력 장치 제어

**Isolated I/O**

* 입출력 장치들이 입출력 버스를 통해 CPU와 연결되어 있는 경우
* 메모리는 따로 메모리 버스를 통해 연결
* 입출력은 입출력을 담당하는 명령어를 통해 실행/입출력버스를 통해 해당 장치의 지정, 데이터, 입출력 구분 제어값 전달
* 입출력 명령어가 명령어 집합에 추가되어 제어로직 복잡
* 입출력 버스를 장착하는데 추가비용

**Memory-mapped I/O**

* CPU가 입출력 장치를 엑세스할 때, 입출력과 메모리의 주소공간을 공동 데이터버스, 주소버스, 제어버스 등으로 구분하지 않고 하나의 메모리 공간에 취급하여 배치하는 방식
* 입출력을 위한 명령어를 따로 사용않고, 메모리에 대한 명령어를 활용하여 입출력 수행
* 입출력 장치들은 각각 메모리의 한 번지를 할당받아 입출력 수행하기에 메모리를 동적으로 사용 불가

---

### MBR

> Master Boot Record

* 부팅 시, OS가 메모리에 적재될 수 있도록 디스크의 시작 섹터에 위치하고 있다.
* BIOS는 ROM에 적재되어 있고 각 장치의 부트로드 이전에 데이터흐름을 세팅한다.

---

### MMU

> Memory Management Unit

* 가상 메모리의 주소를 물리 주소로 변환하는 기능

---

### Critical Section

 **1. 상호 배제(mutual exclusive)** : 한 프로세스가 임계 구역에서 실행하고 있으면 어떤 프로세스도 임계 구역에 진입할 수 없어야 한다. SW로 가능하지만, 매우 복잡하여 HW로 대부분 보조한다.

 **2. 진행(progress)** : 임계 영역 안에서 실행하고 있는 프로세스가 없는 경우, 임계 영역을 실행하고자 하는 프로세스는 반드시 임계 영역을 실행할 수 있어야 한다. 이를 만족하면 진행 조건을 만족한다고 할 수 있다. 

 **3. 한계 대기(bounded waiting)** : 임계 영역을 요청한 프로세스는 무한히 대기하면 안된다. 즉, 제한된 대기 시간을 가져야 한다. 이를 만족하면 한정 대기 조건을 만족한다고 할 수 있다.

---

### 부동소수점(IEEE 754)

**특징**

* 32비트로 구성
* 0은 특별한 값으로 정의한다.

**구성**

* 부호부 (1비트) : 양수일 때는 0, 음수일 때는 1
* 지수부 (부호가 있는 정수, 8비트) : 제일 앞의 1비트는 부호를 정하고, 나머지 7비트로 표시
* 정규화된 가수부 (부호가 없는 정수, 23비트) : 제일 앞의 비트는 정규화되었으므로 1이다.

---



