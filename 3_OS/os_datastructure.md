# 자료구조

</br>

### 배열/연결리스트

![image](https://user-images.githubusercontent.com/75229881/127800889-4b507fd0-f332-4aa6-bb21-8c5f23d7ad7c.png)

* 삽입/삭제의 경우 배열은 나머지 배열들의 Shift가 발생한다. 따라서 연결리스트가 효율적
* 탐색/접근의 경우 배열이 효율적

---

### 허프만 트리

> 빈도 수를 바탕으로 가변길이 코드를 구현하여 데이터를 압축

ex) "ABBCCCDDDDEEEEEFFFFFF"

![image](https://user-images.githubusercontent.com/75229881/116199740-6eaeec80-a772-11eb-9451-98615c1f7e5a.png)

* 고정길이 코드 

  * A ~F, 6개의 문자를 구분하기 위해 3bit 필요
  * 000/001/001/010/010/010/011/011/011/011/100/100/100/100/100/101/101/101/101/101/101

* 가변길이 코드

  ![image](https://user-images.githubusercontent.com/75229881/116199534-314a5f00-a772-11eb-9e39-263884c0f507.png)

  * 그림과 같이 최소 빈도를 우선으로 트리를 구성하여 코드 생성
  * 최대 힙에서 가장 적은 빈도 수의 노드를 반복적으로 넣어서 합쳐준다(미리 만든 트리 포함)
  * 100010011001101101101000000000101010101111111111111
  * 가중치 곱은 예를 들어 B의 경우 거리가 4고 값이 2 이므로 8이다.

---

### AVL 트리

* 특성
  * 노드의 두 하위 트리(왼쪽, 오른쪽)의 높이의 차이가 최대 1을 넘지 않는다
  * AVL 트리는 엄격하게 균형을 유지하기 때문에 Red-black 트리보다 더 빠른 조회성능을 가지지만 더 많은 작업을 수행해야만 한다
  * 삽입/삭제/탐색 연산에 최악의 경우에도 O(logN)을 보장한다
  * 불균형 시 회전을 통해 균형을 맞춘다
* Balance Factor(BF)
  * 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것. 두 서브트리의 높이가 같거나 리프노드라면 BF는 0
  * 각 노드에 대해 BF를 저장하므로 노드마다 int 값의 저장공간이 필요

---

### Red-Black 트리

* 특성
  * Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행
  * Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용
  * Red-Black 트리는 노드당 1비트의 정보만 필요(플래그 반전으로 색상변경만 시키면 됨)
  * 레드 블랙 트리의 균형을 책임지는 건 "루트부터 리프까지 블랙 노드의 개수는 같아야한다는 조건", 레드는 중복될 수 없으니 반드시 레드와 레드 사이엔 하나의 블랙 노드를 끼게 되고 이는 곧 레드 블랙 트리의 총 깊이가 된다.

---

### Trie

> Digtal Tree, Radix Tree, Prefix Tree라고도 불림
>
>  문자열을 저장하고 탐색하는데 유용한 자료구조

<img src = "https://user-images.githubusercontent.com/75229881/116357197-2e657200-a837-11eb-8a56-ec5c12f8525d.png" width="500px">

* 문자열 길이가 N일 때, O(N)을 보장
* 공간복잡도가 단점

---

### 보간탐색

* 정렬된 리스트

* x를 탐색할 때, pos
  * pos = low + (x - arr[low]) * (high - low) / (arr[high] - arr[low])

---

### 해싱

* 정적해싱

  > **Synonym)** 동일한 홈 주소로 인하여 충돌이 일어난 레코드의 집합

  * 제산법
    * index = key % bucket_size
  * 폴딩법
    * 마지막 요소를 제외한 key를 일정한 길이로 나눈 뒤 더하거나 XOR 하는 방법
    * ex) key = 33662572, size = 1000 라면, index = (336+625+ 72) % 1000 = 33
  * 중간제곱법
    * key를 제곱한 뒤, 중간의 일정한 길이의 비트를 인덱스로 사용
  * 숫자분석법
  * 기수변환법

* 동적해싱

  * 확장해싱
    * 필요한 경우 비트열을 하나씩 추가하는 방법

---

