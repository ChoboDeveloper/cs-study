# 자료구조

</br>

### 배열/연결리스트

![image](https://user-images.githubusercontent.com/75229881/127800889-4b507fd0-f332-4aa6-bb21-8c5f23d7ad7c.png)

* 삽입/삭제의 경우 배열은 나머지 배열들의 Shift가 발생한다. 따라서 연결리스트가 효율적
* 탐색/접근의 경우 배열이 효율적

---

### 허프만 트리

> 빈도 수를 바탕으로 가변길이 코드를 구현하여 데이터를 압축

ex) "ABBCCCDDDDEEEEEFFFFFF"

![image](https://user-images.githubusercontent.com/75229881/116199740-6eaeec80-a772-11eb-9451-98615c1f7e5a.png)

* 고정길이 코드 

  * A ~F, 6개의 문자를 구분하기 위해 3bit 필요
  * 000/001/001/010/010/010/011/011/011/011/100/100/100/100/100/101/101/101/101/101/101

* 가변길이 코드

  ![image](https://user-images.githubusercontent.com/75229881/116199534-314a5f00-a772-11eb-9e39-263884c0f507.png)

  * 그림과 같이 최소 빈도를 우선으로 트리를 구성하여 코드 생성
  * 최대 힙에서 가장 적은 빈도 수의 노드를 반복적으로 넣어서 합쳐준다(미리 만든 트리 포함)
  * 100010011001101101101000000000101010101111111111111
  * 가중치 곱은 예를 들어 B의 경우 거리가 4고 값이 2 이므로 8이다.

---

### AVL 트리

* 특성
  * 노드의 두 하위 트리(왼쪽, 오른쪽)의 높이의 차이가 최대 1을 넘지 않는다
  * AVL 트리는 엄격하게 균형을 유지하기 때문에 Red-black 트리보다 더 빠른 조회성능을 가지지만 더 많은 작업을 수행해야만 한다
  * 삽입/삭제/탐색 연산에 최악의 경우에도 O(logN)을 보장한다
  * 불균형 시 회전을 통해 균형을 맞춘다
* Balance Factor(BF)
  * 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것. 두 서브트리의 높이가 같거나 리프노드라면 BF는 0
  * 각 노드에 대해 BF를 저장하므로 노드마다 int 값의 저장공간이 필요

---

### Red-Black 트리

* 특성
  * Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행
  * Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용
  * Red-Black 트리는 노드당 1비트의 정보만 필요(플래그 반전으로 색상변경만 시키면 됨)
  * 레드 블랙 트리의 균형을 책임지는 건 "루트부터 리프까지 블랙 노드의 개수는 같아야한다는 조건", 레드는 중복될 수 없으니 반드시 레드와 레드 사이엔 하나의 블랙 노드를 끼게 되고 이는 곧 레드 블랙 트리의 총 깊이가 된다.

---

### Trie

> Digtal Tree, Radix Tree, Prefix Tree라고도 불림
>
>  문자열을 저장하고 탐색하는데 유용한 자료구조

<img src = "https://user-images.githubusercontent.com/75229881/116357197-2e657200-a837-11eb-8a56-ec5c12f8525d.png" width="500px">

* (탐색 시) 문자열 길이가 N일 때, O(N)을 보장
* 공간복잡도가 단점

**트라이 색인**

* 가변 길이의 키 값을 효율적으로 나타낼 수 있다
* 삽입 및 삭제 시 노드의 분열과 병합이 없다
* 트라이의 차수는 키 값을 표현하기 위해 사용하는 문자의 수(Radix)에 의해 결정된다
* 키 값의 푼포를 미리 예측할 수 있다면 기억장소를 절약할 수 있다
* 트라이의 크기는 나타내려고 하는 키 값의 기수와 키 필드 길이에 의해 결정

---

### 탐색

<br>

**보간탐색**

* 보간탐색은 이진탐색을 개선한 것인데 이진탐색처럼 비교 대상을 무조건 mid = (high-low)/2 로 하지 않고 우리가 찾는 원소는 전체 데이터 값을 보니 대충 이정도에 있겠구나 추측하여 탐색하는 방식
* x를 탐색할 때, pos
  * pos = low + (x - arr[low]) * (high - low) / (arr[high] - arr[low])

**제어탐색**

* 제어 검색은 반드시 순서화된 파일이어야 검색할 수 있다
* 한번의 비교 동작이 끝난 후 비교 대상이 된 레코드를 다음에 비교할 대상을 선택하는 기준으로 이용하여 검색하는 방식이다.

**블록탐색**

* 블록 검색을 위해서는 파일을 구성하는 레코드들을 다음과 같이 구성해 놓아야 한다.
* 파일을 구성하는 레코드들을 여러개의 Block으로 분할하여 Block단위는 순서화 시키고 Block내의 자료는 순서화와 관계없이 저장시킨다.
* Index부분을 두어, 각 Block마다 최대 레코드 키 값을 가지는 레코드 번호를 저장시킨다.
* 인덱스를 이용하여 찾고자 하는 레코드가 어느 Block에 속하는지 검색한 후, 해당 Block내에서는 선형 검색을 한다.

**피보나치 탐색**

* 피보나치 검색은 피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색하는 방식이다.
* 이분 검색에서는 중간 레코드 번호를 계산하기 위해서 나눗셈이 필요하지만 피보나치 검색은 가감산만을 이용하기 때문에 효율이 우수하다.

---

### 해싱

* 정적해싱

  > **Synonym)** 동일한 홈 주소로 인하여 충돌이 일어난 레코드의 집합

  * 선형조사법
    * index = index + 1
    
  * 제산법
    * index = key % bucket_size
    
  * 폴딩법
    * 마지막 요소를 제외한 key를 일정한 길이로 나눈 뒤 더하거나 XOR 하는 방법
    
    * 이동폴딩
    
      ![image](https://user-images.githubusercontent.com/75229881/162177339-b7a9160b-b005-4b56-ad7e-925bc20d3d9d.png)
    
    * 경계폴딩
    
      ![image](https://user-images.githubusercontent.com/75229881/162177456-4d40e040-9a29-4e3d-a2cc-9b0aed8fc930.png)
    
  * 중간제곱법
    * key를 제곱한 뒤, 중간의 일정한 길이의 비트를 인덱스로 사용
    
  * 숫자분석법

    * 레코드 키를 구성하는 수들이 모든 키들 내에서 각 자리별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택하여, 레코드의 홈 주소로 사용하는 방법

    * ```
      index) 4, 8, 10
      012 - 452 - 0236   =>     426
      012 - 153 - 0530   =>     150
      015 - 342 - 0935   =>     395
      012 - 752 - 1032   =>     702
      012 - 852 - 0470   =>     840
      012 - 543 - 0231   =>     512
      ```

  * 기수변환법

    * 기수 변환법은 어떤 진법으로 표현된 주어진 레코드 키를 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방법으로, 어떤 키 값이 16진법으로 표현되어 있다면 이를 10진법으로 표현된 것으로 간주하고 키 값을 변환하여 해당 레코드의 홈 주소를 구한다.

* 동적해싱

  * 확장해싱
    * 필요한 경우 비트열을 하나씩 추가하는 방법

---

### B-Tree

* 가장 상단의 노드를 '**루트 노드(Root Node)**', 중간 노드들을 '**브랜치 노드(Branch Node)**', 가장 아래 노드들을 '**리프 노드(Leaf Node)**'라고 한다. 
* **참고사항**

> ! 루트와 잎 노드를 제외한 **트리의** **노드는** **최소** **⌈m/2⌉개의** **서브트리를** **가져야** **한다.** 여기서 m은 차수를 의미하는데 예를 들어 m이 3이면, 내부노드는 최소 ⌈3/2⌉ = 2개의 서브트리를 가져야 한다는 뜻이다. 차수가 3이기 때문에 각각의 노드는 2개의 키를 가진다.

---

### B+Tree

* B+tree는 B-tree의 확장개념으로, **B-tree의 경우**, internal 또는 branch 노드에 key와 data를 담을 수 있다. 하지만, **B+tree의 경우** 브랜치 노드에 key만 담아두고, data는 담지 않는다. 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다. 
* **인덱스 세트와 순차 세트**로 구성되어있다.

- 인덱스 세트
  - 리프 이외의 노드로 구성
  - 키 값만 저장
  - 리프 노드를 접근하는 경로로만 이용
- 순차 세트
  - 리프 노드들로 구성
  - 실제 모든 <키 값, 데이터 레코드의 주소>들이 저장
  - 키 값의 순서에 따라 모든 레코드를 순차 접근하는데 이용
- **참고사항**

> ! 키값이 인덱스 세트에서 발견되더라도 레코드가 반드시 있다는 것은 아니다(인덱스 세트에서 있다고 해서 순차세트에서 이미 삭제되어 있을 수 있기 때문)
>
> ! 검색은 항상 리프노드 까지 내려가야만 종료
>
> ! 검색하고자 하는 키 값이 인덱스 세트에서 발견되더라도 리프 노드까지 내려가야만 실제 레코드의 주소를 알 수 있다.

---
