# UNIX/Linux

<br>

### UNIX 시스템 구성

* Kernel
  * 태스크(Task) 관리자
    * 물리적 자원인 CPU를 추상적 자원인 태스크로 제공
  * 메모리(Memory) 관리자 
    * 물리적 자원인 메모리를 추상적 자원인 페이지나 세그먼트로 제공
  * 파일 시스템(File System) 관리자
    * 물리적 자원인 디스크를 추상적 자원인 파일로 제공
  * 네트워크(Network) 관리자
    * 물리적 자원인 네트워크 장치를 추상적 자원인 소켓으로 제공
  * 디바이스 드라이버(Device Driver) 관리자
    * 각종 외부 장치에대한 접근
* Shell
  * 사용자가 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
  * 시스템과 사용자간의 인터페이스 담당
* Utility Program
  * 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용
  * 에디터, 컴파일러, 인터프리터, 디버거 등

---

### IPC

> Inter-Process Communication
>
> UNIX 시스템은 다양한 종류의 프로세스 간 통신을 지원
>
> 각 프로세스는 시스템호출을 통해 커널의 기능을 사용하며, 프로세스간 통신은 Signal, Pipe, Socket 등을 사용한다

* 시그널(Signal) : 간단한 메세지를 이용하여 통신하는 것으로, 초기 UNIX 시스템에서 사용됨
* 파이프(Pipe) : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식
* 소켓(Socket) : 프로세스 사이의 대화를 가능하게하는 쌍방향 통신방식
* 메시지 큐(Message Queue), 공유 메모리(Shared Memory), 세마포어(Semaphore) 등

---

### 파일

* 일반 파일(Regular File)

  * 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 구성
  * 정규 파일은 표준 파일 입출력 시스템 호출을 통해 참조됨
* 디렉토리 파일(Directory File)
  * 다른 파일의 목록 혹은 포인터를 가지는 파일
  * 디렉토리 파일은 디렉토리의 명시적인 시스템 호출을 통해 참조됨

* 특수 파일(Special File)
  * 프린터와 터미널, 디스크 같은 주변 장치나 또는 파이프와 소켓 같은 프로세스 간 상호 통신 기법에 해당
  * 표준 입출력 시스템 호출을 통해 참조됨

---

### 디렉토리 구조

![image](https://user-images.githubusercontent.com/75229881/163799805-2d9c4e53-40a2-475c-934f-62876abcc1a6.png)

#### /(루트)

최상의 디렉토리인 루트 디렉토리를 의미하며, 리눅스의 모든 디렉토리들의 시작점이다. 즉, 모든 디렉토리들을 절대경로로 표기할 때에 이 디렉토리로부터 시작해야 한다.

#### /bin

기본적인 **명령어가 저장**된 디렉토리. 즉, 리눅스 시스템사용에 있어 가장 기본적이라고 할 수 있는 mv, cp, rm 등과 같은 명령어들이 이 디렉토리에 존재하며 root 사용자와 일반사용자가 함께 사용할 수 있는 명령어 디렉토리이다.

#### /etc

시스템의 거의 모든 **설정파일이 존재**하는 디렉토리. /etc/sysconfig(시스템 제어판용 설정파일), /etc/passwd(사용자관리 설정파일), /etc/named.conf(DNS 설정파일) 등과 같은 파일들이 존재한다.

#### /home

사용자의 홈디렉토리, useradd 명령어로 새로운 사용자를 생성하면 대부분 사용자의 ID와 동일한 이름의 디렉토리가 자동으로 생성됨

#### /lib

커널모듈파일과 라이브러리파일 즉, 커널이 필요로하는 커널모듈파일들과 프로그램(C, C++ 등)에 필요한 각종 라이브러리 파일들이 존재하는 디렉토리

#### /usr

이 계층에는 **시스템이 아닌 사용자가** 실행할 프로그램들이 저장되며, 해당 계층에는 반드시 read-only 데이터만 존재해야한다.

#### /var

시스템운용중에 생성되었다가 삭제되는 데이터를 **일시적으로 저장**하기 위한 디렉토리. 거의 모든 시스템로그파일은 /var/log 에 저장되고, DNS 의 zone 설정파일은 /var/named 에 저장되고, 메일파일은 /var/spool/mail 에 저장되며, 크론설정파일은 /var/spool/cron 디렉토리에 각각 저장됨

#### /proc

* 프로세스에 대한 정보가 있는 디렉토리, 실제로는 빈 디렉토리이며 시스템이 부팅되면서 시스템의 프로세스 정보가 저장된다.
* 디스크상에 실제 존재하는 것이 아니라 메모리상에 존재하기 때문에 **가상파일시스템**이라고 부른다. 
* /proc엔 현재 실행중인 PID와 같은 이름의 폴더들이 생성된다.
* ps]라는 명령어는 이 폴더의 내용을 조회해서 보여 준다.

---

### 세부 디렉토리

#### /usr/bin/

일반 사용자들이 사용가능한 명령어 파일들이 존재하는 디렉토리

#### /etc/crontab

리눅스에서는 일반적으로 cron 데몬이 주기적인 작업 실행을 처리한다. cron이 시작될 때부터 끝날 때까지 계속 실행되며 실행되며 cron 설정 파일은crontab이라 부른다.

#### /var/log/

시스템로그파일(messages, secure, xferlog 파일등)이 저장되는 디렉토리

---

### 기본 명령어

* ls(List) : 파일이나 디렉토리 정보 출력
* pwd(print work directory) : 작업중인 디렉토리 확인
* cd : 이동
* mkdir(Make Directory) : 디렉토리 생성
* rmdir : 디렉토리 삭제
* cat(catenate) : 파일 내용 출력
* cp : 복사
* touch : 파일의 접근 및 수정 시간 변경
* tail : 로그파일 변경을 실시간으로 확인가능
* find : 파일, 디렉토리 검색

---

### 권한 명령어

* ls -al
  * 모든 파일의 퍼미션정보를 볼 수 있음
  *  d/rwx/rwx/rwx 여기서 d 다음으로 순서대로 소유자, 그룹, 일반유저에 대한 권한
  * 맨 앞글자 d는 디렉토리(폴더), -는 일반파일
  
* chown : 파일 및 디렉토리의 소유권을 바꾸는 명령어

  * chown [옵션] [소유권자:그룹식별자] [파일명]
  * 하위 사용자는 최고 권한 사용자인 root에게 권한부여를 할 수 없다. (소유자 변경도 마찬가지)
  * 예제
    *  chown member1 test.c (파일에 대해 소유자를 member1로 바꾼다)
    *  chown :member1 test.c (파일에 대해 그룹을 members1로 바꾼다)
    *  chown member1: test.c (파일에 대해 소유자 및 그룹을 members1로 바꾼다.)
    *  chown member1:member2 test.c (파일에 대해 소유자는 member1, 그룹은 member2로 바꾼다)
  
* chmod : 파일, 디렉토리의 권한을 변경하는 명령어
  * chmod [권한값] [파일명]
  
  * **u**ser, **g**roup, **o**thers, **a**ll
  
  * +는 권한 부여, -는 권한 취소
  
  * 예제
    * chmod **g+w** test.c (그룹에 쓰기 권한을 준다)
    * chmod **o-r** test.c (기타사용자에게 읽기 권한을 빼앗는다)
    *  chmod **707** test.c (user, other 은 모두 rwx로 변경하고 group은 모든 권한을 제거)
    
  * 특수권한
    
    * **s(SetUID), s(SetGID), t(StickyBit)**
      * 실행권한 자리 "x" 대신에 s, s, t
      * 파일에 실행권한 'x'가 없었으면 대문자 S, S, T
    * 4777= SetUid 설정 때 4000을 더함
    * 2777= SetGid 설정 때 2000을 더함
    * 1777= Sticky bit 설정 때 1000을 더함
    * chmod **u+s** test.c 처럼 사용가능
    * setUid시 실행권한이 있으면 s표기, 없으면 S표기
    
  * 예제
  
    * ```shell
      -rw-r--r-- 1 user1 manager 17 Mar 24 03:17 FILE
      ```
  
    * -(파일타입) / rw-(소유자) r--(그룹) r--(기타사용자)
  
    * user1(파일소유자)
  
    * manager(그룹)
  
    * ```
      -rwsr--r-- 1 user2 manager 17 Mar 24 03:17 first
      ```
  
    * chmod 4744 first(SetUid 설정)
  
* umask : 새로 만들어진 파일에 파일 권한을 어떻게 설정할지를 제어하는 마스크 설정을 결정하는 명령어

  * 디렉토리=777, 파일=666 에서 umask값을 뺀다
  
* **grep** : 파일 내 정규표현식을 포함한 모든 행을 검색 및 출력하는 명령어
  *  파일의 내용이나 콘솔에 출력물 중에 특정 문자열을 찾는데 널리 사용된다.
  
* **find** : 원하는 조건의 파일, 디렉토리 모든 것을 검색한다.

---

### 로그 관련

* /var/log/messages
  * 로그 파일중 가장 중요하고 기본적인 부분으로 시스템이 운영되는 전반적인 내용이 기록되는 파일
  * 로그인 기록부터 디바이스 정보 , 시스템 설정오류 , 파일 시스템 , 네트워크 세션기록 등 주로 시스템 데몬들의 실행상황과 내역, 그리고 사용자들의 접속정보
*  /var/log/secure
  * 최근 서버 접속자 기록
  * 텍스트 파일로 **grep** 명령어 사용
* /var/log/**lastlog**
  * /etc/passwd에 존재하는 모든 계정을 대상으로 하여 언제 마지막으로 서버에 접속을 했는지를 확인
  * Mail, adm, bin 등의 계정들은 모두 Never logged in
* /var/log/**wtmp**
  * 최근 로그인/로그아웃 정보, 시스템의 Boot/Shutdown 정보에 대한 누적정보
  * **last** 명령어 사용
* /var/log/**utmp**
  * 현재 로그인한 사용자의 상태정보를 담고 있는 파일
  * **w,who,finger**등의 명령어 사용
* /var/log/**btmp**
  * 실패한 로그인 시도에 대한 기록을 담고 있는 파일
  * **lastb** 명령어 사용
* /var/log/xferlog
  * FTP 로그파일

---

### 계정 관련

* /var/account/**pacct**
  * 사용자별 명령실행 정보
  * binary 파일로 내용 확인시 **lastcomm** 명령어 사용

* /etc/passwd
  * 계정정보 및 패스워드 파일

  * 예시

    ```
    postgres:x:111:121:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
    (사용자명:PW:UID:GID:정보:홈디렉토리:Shell환경)
    ```

  * pwconv 명령어로 shadow 활성화 / pwunconv 비활성화

  * PW가 x면 Shadow로 암호화 되어있음을 의미한다.
  
* /etc/shadow
  * 암호화된 패스워드 파일
  * abcd:$Hashid$Salt$Hash vlaue:17562:0:99999:7:3::과 같이 구성
    * abcd : 사용자의 계정명
    * Hashid : MD-5 : $1, SHA-256 : $5, SHA-512 : $6
    * 17562 : 최종수정일을 70년기준으로 계산
    * 0 : 암호최소사용일, 0일만큼 비밀번호 유지해야함
    * 99999 : 최대사용일, 99999만큼 변경안해도 됌
    * 7 : 만료경고일, 만료 7일전부터 경고
    * 3 : 만료 유예기간 이후에는 로그인 불가

---

### 시그널

* 프로세스 간 통신
* 비동기식 통신

| **번호** | **이름**       | **설명**                                                     | **기본 처리**  |
| -------- | -------------- | ------------------------------------------------------------ | -------------- |
| 1        | SIGHUP(HUP)    | HangUP의 약어로 로그아웃과 같이 터미널에서 접속이 끊겼을 때 보내지는 시그널입니다. | 종료           |
| 2        | SIGINT (INT)   | 키보드로부터 오는 인터럽트 시그널로 실행을 중지              | 종료           |
| 3        | SIGQUIT (QUIT) | 키보드로부터 오는 실행 중지 시그널                           | 코어 덤프      |
| 4        | SIGILL (ILL)   | illegal instruction의 약자입니다. 잘못된 명령을 사용했을 때 발생합니다. | 코어 덤프      |
| 5        | SIGTRAP (TRAP) | trace(추적), breakpoint(중지점)에서 TRAP 발생할 때           | 코어 덤프      |
| 6        | SIGABRT (ABRT) | abort의 약자로 비정상종료 함수에 의해 발생합니다. (즉 abort 시스템 호출을 하였을 때 발생) | 코어 덤프      |
| 7        | SIGBUS         | 메모리 접근 에러시 발생하는 시그널입니다.                    | 코어 덤프      |
| 9        | SIGKILL (KILL) | KILL! 무조건 종료, 즉 프로세스를 강제로 종료시키는 시그널!   | 종료           |
| 11       | SIGSEGV        | invalid memory reference                                     | 종료 +코어덤프 |
| 15       | SIGTERM (TERM) | Terminate의 약자로 가능한 정상 종료시키는 시그널로 kill 명령의 기본 시그널입니다. | 종료           |
| 17       | SIGCHLD(child) | 자식 프로세스가 stop 되거나 종료되었을 때 부모에게 전달되는 신호입니다. (멀티 프로세스 코딩에서 자세한 사용법은 배울 거..) | 무시           |
| 18       | SIGCONT (CONT) | Continue의 약자로 STOP 시그널에 의해 정지된 프로세스를 다시 실행시킬 때 사용됩니다. | 재시작         |
| 19       | SIGSTOP (STOP) | 터미널에서 입력된 정지 시그널입니다. SIGCONT로 재실행시킬 수 있습니다. | 중지           |
| 20       | SIGTSTP (TSTP) | 실행 정지 후 다시 실행을 계속하기 위해 대기시키는 시그널입니다.[CTRL] + [z]를 입력했을 때 보내지는 시그널입니다.SIGCONT로 역시 다시 실행시킬 수 있습니다. | 중지           |
| 29       | SIGIO          | 비동기 입출력이 발생했을 경우 ! (I/O now possible!)          | 종료           |

---

### 파일 디스크립터

* 파일 디스크립터(File Descriptor)란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. **파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다.** 
* 흔히 유닉스 시스템에서 모든 것을 파일이라고 한다. 일반적인 정규파일부터 디렉토리, 소켓, 파이프, 블록 디바이스, 케릭터 디바이스 등 모든 객체들을 파일로 관리한다. 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용한다. **프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.**
* 특징
  * 사용자는 직접 참조할 수 없음
  * 일반적으로 파일 Open 시, 보조기억장치에서 주기억장치로 Load 됌
  * 파일 제어 블록(FCB)이라고 할 수 있다.

---

### 링크

> 윈도우로 치면 "바로가기" 같은 개념으로, 리눅스에도 링크 기능이 있다. 특정 파일이나 디렉터리를 링크 걸어 사용할 수 있는데, 링크에는 두 종료가 있다.
>
> 하드링크, 심볼릭링크 모두 수정 시 원본파일 또한 수정된다.

**하드링크**

* 원본 파일과 동일한 inode 를 가진다. 따라서, 원본 파일이 삭제 되더라도 원본 파일의 inode 를 갖고 있는 링크 파일은 사용이 가능하다.
* 같은 inode 를 가리키는 파일이기 때문에 이름만 다를 뿐 같다고 생각하면 된다.
* 동일한 파일 시스템 내에서만 하드 링크를 가질 수 있다.

```
cp 명령어와 다를 것이 없다고 생각할 수 있지만
cp 명령어를 통해 파일을 복사하게 되면 하나의 파일이 생성되기 때문에 용량은 배로 늘어난다.
이런 부분에서 cp 명령어와의 차이점을 확인해볼 수 있다.
```

**심볼릭링크**

* 원본 파일의 이름을 가리키는 링크라고 생각하면 된다. 따라서, 원본 파일이 사라지게 되면 파일이 제대로된 역할을 할 수 없다.
* 심볼릭 링크의 장점은 전혀 다른 파일이라도 원본 파일과 이름이 같다면 계속 사용할 수 있다.
* 파일 및 디렉토리에 대한 링크를 만들 수 있으며 다른 파티션에서 원본과 다른 inode 번호로 링크 (바로 가기)를 만들 수 있습니다.

---

* 

---

### I-node(아이노드)

![image](https://user-images.githubusercontent.com/75229881/163800875-3431e39c-9d3d-4621-9c0b-2c5a049053d7.png)

**구성**

- 파일 모드(i_mode)
- 소유자명(i_uid)
- i-node의 크기(i_size_lo)
- 마지막 접근 정보(i_atime)
- 마지막 수정 정보(i_mtime)
- i-node 수정 정보(i_ctime)
- 해당 파일이 가지고있는 데이터 블록의 갯수 저장(i_blocks)

<br>

**I_blocks**

* 여기에서 보면 한 엔트리당 크기가 **32비트인(포인터라서)**, 길이가 EXT4_N_BLOCKS인 배열변수이다. inode구조에서 i_block은 파일에 속한 디스크블록들의 주소를 저장하는 포인터배열이며 길이는 통상 15이다.

  ![image](https://user-images.githubusercontent.com/75229881/163801220-65a07fcf-06c2-4cde-b8e9-baf7115787eb.png)

* 총 15개의 엔트리로 구성되는데 12개는 direct block이라고 하며, 나머지 3개는 indirect block이다.

![image](https://user-images.githubusercontent.com/75229881/163801131-756be1fd-9867-4c1e-9899-81b70c7486f5.png)

* 우선 i_block 배열은 12개의 direct block과 3개의 indirect block으로 구성되어 총 15개의 엔트리를 갖는다고 하였다.

* direct block은 실제 파일의 내용을 담고있는 디스크의 데이터 블록을 가리키는 포인터변수이다. 

  * 그림에서 처럼 해당 파일에 속하는 디스크에 위치한 실제 데이터 저장장소를 가리킨다. 그런데 direct block은 12개 밖에 없다. 일반적으로 하나의 데이터 블록의 크기는 페이지프레임(page frame)의 크기와 동일하므로  일반적으로 4KB가 되는데 이대로라면 4KB짜리 데이터 블록 12개만큼을 한 파일에서 저장공간으로 사용할 수 있다는 이야기가 된다. 
  * 4KB * 12개 = 48, 즉 0-11까지의 총 12개의 직접블록으로 가질 수 있는 한 파일의 최대 크기는 고작 48KB이다.

* single indirect block은 하나의 인덱스 블록을 갖는다고 하였다. 하나의 데이터 블록을 인덱스 블록으로 만든 후 더 많은 데이터 블록을 가리키게 하는 것이다. 이렇게 하면 고작 하나의 데이터 블록의 크기로 훨씬 더 많은 데이터 블록을 가리킬 수 있게 된다.

  * 한개의 블록이 4KB, 즉 4096byte이고 주소를 가리키는 포인터는 4byte이다. 계산을 해보면 한 블록으로 (4096byte / 4byte = ) 1024개의 포인터를 표현할 수 있고 이 말은 즉, 한 블록이 가리킬 수 있는 주소공간은 1024개가 되는 것을 의미한다. 위에서 한 블록의 최소 크기가 4KB이라고 가정하였으니 single indirect block으로 표현할 수 있는 한 파일의 최대 크기는 4KB(데이터블록 한개) * 1024개(의 포인터) = 4096KB, 즉 4MB가 된다.

    >  데이터블록의 최소 단위가 4KB라고 가정하였으므로, 최소 파일의 크기도 4KB가 된다. 파일에 아무것도 기록하지 않아도 생성자체만으로도 4KB를 확보하게 된다는 말이다.

* double indirect block은 말그대로 인덱스 블록을 이중으로 가진다

  * 1024개 * 1024개 * 4KB(한 블록의 크기) = 4GB, 즉 double indirect block로 가질 수 있는 최대 파일의 크기는 4GB이다.

* triple indirect block

  * 인덱스 블록을 3중으로 가지므로 계산은 1024 * 1024 * 1024 * 4KB = 4TB 이렇게 된다. 즉, 여기서의 최대 파일의 크기는 4TB이다.

<br>

* 최종적으로 inode구조에서 지원할 수 있는 최대 파일의 사이즈는 direct block + single indirect block + double indirect block + triple indirect block이므로 48KB + 4MB + 4GB + 4TB가 된다.

  > 하지만 32bit환경에서 리눅스가 지원하는 실제 파일 사이즈는 4GB(or 2GB)인데, 이는 node가 4TB정도의 파일을 지원할 수 있다고 하더라도, 리눅스 커널 내부의 파일 관련 함수들이 사용하는 변수나 인자들이 32bit로 구현되어 있기때문이다. (예. f_pos, 2^32 = 4GB...... 가 표현할 수 있는 최대 file offset이 됨)


---

