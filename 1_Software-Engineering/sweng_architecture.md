# SW공학/아키텍처

<br>

### 아키텍처

* 설계과정
  1. 설계 목표 설정 : 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
  2. 시스템 타입 설정 : 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
  3. 스타일 적용 및 커스터마이즈(아키텍처 패턴 적용) : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계
  4. 서브시스템 기능, 인터페이스 작성 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의
  5. 아키텍처 설계 검토
* 시스템 타입의 종류
  * **대화형** 시스템 : 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템
  * **이벤트 중심** 시스템 : 외부의 상태에 따라서 변화를 주어 동작하는 시스템
  * **변환형** 시스템 : 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
  * **객체 영속형** 시스템 : 데이터 베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템

---

### 시스템통합

![image](https://user-images.githubusercontent.com/75229881/124056884-800dc100-da61-11eb-9e6c-7cfde3565d64.png)

**모놀리식 아키텍처**

* UI 및 비즈니스 로직, 데이터베이스 액세스 로직 모두가 하나의 애플리케이션 산출물로 패키징되고 애플리케이션 서버에 배포되는 것 (단일 코드 베이스)

* 모놀리식 아키텍처의 단점

  1️⃣ **첫째**, 기능이 많아진다는 것은 하나의 프로젝트에 코드들이 무수히 많아진다는 것을 의미한다. 코드가 많아지면 코드를 이해하고 해석하고 개발하는데 시간이 오래걸리는 것을 의미한다. 이는 **유지보수가 어려워진다고** 할 수 있다.

  2️⃣ **둘째,** 하나의 시스템에 모든 기능이 담겨있다면 기능 하나가 수정되면 전체를 다시 빌드하고 배포해야 한다. 만약 시스템의 크기가 크다면 빌드 및 배포 시간이 늘어난다는 것을 의미한다. 이는 **버그나 수정사항의** **즉시 적용이 어렵다는 점**을 내포한다.

  3️⃣ **셋째**, 만약 **특정 기능에 오류**가 발생했다고 가정해보자. 해당 오류로 시스템이 죽으면 **전체가 시스템이 먹통**이 된다. 이는 **작은 요소가 전체에 영향을 미치는 것**을 내포하는데, 트래픽이 급증하게 되면 전체 시스템에 영향을 미치는 것까지 생각할 수 있다.

  4️⃣ **넷째,** 다양한 기능들은 그 종류에 따라 다양한 언어와 프레임워크를 선택하여 개발할 수 있다. 하지만 MA일 경우, 하나의 시스템으로 구성되기 때문에 **기능별로 알맞은 언어 및 프레임워크를 선택하기 어렵다.**

**시스템통합 문제**

* 메인 프레임 시대에서 유닉스 시스템으로 내려오면서 부터 시스템들은 업무 단위로 분리가 되기 시작했다. ERP,CRM 등과 같은 시스템으로, 은행은 대내,대외,정보계와 같이 시스템으로 잘게 잘게 나눠지기 시작했는데, 당연히 이렇게 나눠진 시스템 사이에는 통신이 필요하게 되었고, 시스템이 거대화 되가면서, 시스템간에 직접 P2P로 통신하는 구조는 한계에 다다르기 시작하였다

**EAI (Enterprise Application Integration)**

* EAI의 가장 큰 특징은 표준화 되지 않은 이기종 시스템간의 연동을 가능하게 해준다는 것이다. 메인프레임 → Unix ERP 시스템으로 데이타를 전송하게 한다던지 Oracle → CRM 시스템으로 데이타를 전송해주는 것과 같은 시스템 통합을 지원했는데, 이는 이기종간에 통신 프로토콜이나 통합 방식을 변경할 수 있는 어댑터를 제공하기 때문이다

**SOA/ESB**

* 이 기종간의 통합이 많아지고, 시스템이 점점 분리되다 보니, 아예 이를 표준화하고자 하는 작업이 진행되었는데, 이것이 바로 SOA (Service Oriented Archtiecture / 서비스 지향 아키텍쳐)이다. (마이크로서비스)
* 웹서비스 기반으로 통신이 표준화(SOAP)되었기 때문에 서비스간의 통신은 EAI처럼 별도의 어댑터가 필요 없어졌다. 대신 서비스간의 통신을 서비스 버스(ESB)라는 통신 백본을 이용하여 통신을 하는 구조가 되었다.

---

### EAI 구축유형

![image](https://user-images.githubusercontent.com/75229881/126605344-79da9988-1f93-4fee-adf5-1e8907eb1890.png)

---

### 아키텍처 패턴

**계층형 패턴**

> - **Presentation layer:** UI, 브라우저에서의 유저와의 통신 로직을 다룸.
> - **Business layer:** 요청에 따른 비즈니스 로직을 다룸.
> - **Persistence layer:** DAO(Data Access Object) , ORM과 관련된 데이터베이스에 접근해서 데이터를 저장, 수정하는 함수 로직을 다룸.
> - **Database layer:** 데이터가 다 저장되어있는 곳. 데이터베이스.

<img src = "https://user-images.githubusercontent.com/75229881/163995684-1651269c-27eb-4767-81ef-6ca6eb3c56c6.png" width="50%">

**장점**

- 시스템 분석이 용이함
- 변화에 대한 영향력을 한정할 수 있어 코딩이나 테스트를 계층별로 진행할 수 있음
- 계층간 구조를 나누어 재사용성이 높음

**단점**

- 계층을 구분하기 어렵고 잘못 구분할 경우 수정이 빈번할 수 있음
- 또한 설계시 계층의 개수 및 규모를 정하기 어려움

<br>

**클라이언트-서버 패턴**

**마스터-슬레이브 패턴**

<img src = "https://user-images.githubusercontent.com/75229881/151334550-707f5967-24aa-49dc-8ed5-4fcd5fffdddb.png" width="60%">

* 실시간 시스템에서 사용
* 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업 분할 -> 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식

**파이프-필터 패턴**

![image](https://user-images.githubusercontent.com/75229881/141670795-d99674af-9d16-44c8-a722-d6be6a8f26d2.png)

* 데이터 스트림 절차의 **각 단계를 필터 컴포넌트로 캡슐화**하여 파이프를 통해 데이터를 전송하는 패턴
* 필터 컴포넌트는 재사용성 좋고 추가가 쉬워 확장이 용이
* 데이터 변환, 버퍼링, 동기화 등에 사용됨
* 대표적으로 Unix의 쉘 방식

**브로커 패턴**

<img src = "https://user-images.githubusercontent.com/75229881/141670826-527a657b-4dfa-4327-87f8-c1a116817659.png" width="60%">

* 이 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호 작용을 할 수 있다. 브로커(broker) 컴포넌트는 컴포넌트(components)간의 통신을 조정하는 역할을 한다.


---

### N-계층구조

**2-Tier 구조**

* **2 - 계층 구조(two-tier archtecture)**에서는 응용 프로그램이 클라이언트 상에 존재하며 질의문을 보냄으로써 서버에 있는 데이터베이스 시스템의 기능을 불러온다. 이때 클라이언트와 서버 사이의 교신을 위해 **ODBC** 나 **JDBC** 와 같응 응용 프로그램 인터페이스 표준이 사용된다.

**3-Tier 구조**

* **3-계층 구조(three-tier architecture)**에서 클라이언트는 어떤 데이터베이스 호출도 직접적으로 수행하지 않고 단지 전처리 시스템으로서의 역할만 한다. 대신, 클라이언트와 **응용 프로그램 서버(application server)** 사이의 교신은 대개 폼 인터페이스를 통해서 이루어진다. 다음으로, 응용 프로그램 서버는 데이터에 액세스하기 위해 데이터베이스 시스템과 통신한다. 
* 어떤 행동(action)이 어떠한 조건 하에서 수행되는지를 가리키는 **비즈니스 로직(business logic)**은 여러 클라이언트에 분산되어 있는 것이 아니라 응용 프로그램 서버 쪽에 포함되어 있다. 3-계층 구조는 world wide web 이나 대규모의 응용 프로그램에 보다 적합하다.

---

### 4+1 view

![image](https://user-images.githubusercontent.com/75229881/161049606-178ebe86-3729-4d9f-8c1e-9c244ca2771c.png)

**Use Case View**

* **사용자**, 설계자, 개발자 및 테스터의 관점
* 주로 **UseCase Diagram, Activity Diagram**으로 표현 

**Logical View**

* **설계자와 개발자 관점**
* 시스템 내부를 조망하고 시스템의 기능성이 어떻게 제공되는지 설명
* 정적 구조와 동적 구조를 다룸
  - 정적 구조: 클래스, 객체, 관계(Class Diagram, Object Diagram)
  - 동적 구조: 객체가 다른 객체에게 메시지를 전달할 때 발생하는 협동구조
* 클래스, 패키지, 컴포지트, 상태 다이어그램 등

**Process View**

* **개발자와 시스템 통합자 관점**
* 프로세스와 프로세서로 구분되는 시스템의 분할을 설명
* 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행 및 비동기, 이벤트의 처리 등
* 시퀀스, 통신, 액티비티 다이어그램 등

**Implement View**

* 구현 모듈과의 의존성 표현
* 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
* 컴포넌트 다이어그램

**Deployment View**

* **개발자, 시스템 통합자 및 테스터 관점**
* 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 맵핑
* 배포 다이어그램

---

### SOA/MSA

**특징**

* **여러 비즈니스 로직**은 기능(모듈)별 **각자의 DB 환경을 공유**하고, 모듈별로 애플리케이션과 **독립적으로 통신하는 것**

* Service Orchestration(오케스트레이션)

  <img src = "https://user-images.githubusercontent.com/75229881/164958542-8d389c00-ff4c-49b5-a412-1494ccf2f4b1.png" width="70%">

  * 오케스트라 지휘자처럼 프로세스를 안내하고 구동하는 하나의 중앙 두뇌에 의존
  * 가장 단순한 작업은 고객 서비스가 마치 중심 뇌처럼 행동하는 것, 고객 서비스 스스로 이 프로세스에서 고객의 위치를 추적할 수 있고, 고객 계정이 설정되었는지, 이메일 또는 우편이 발송되었는지 확인

* Service Choreography(코레오그래피)

  <img src = "https://user-images.githubusercontent.com/75229881/164958560-4b46c15c-1063-4008-b7d2-170fffe328db.png" width="70%">

  * 코레오그래피 방식에서는 고객 서비스가 비동기 방식으로 **'고객이 생성되었다'** 라는 이벤트를 발산
  * 적립 포인트 은행, 우편 서비스, 이메일 서비스는 모두 아래 그림과 같이 구독하고 적절히 행동
  * 이 방식이 확실하게 느슨한 결합을 가진다. 만약 다른 서비스가 생성과정에 참여하고자 한다면 단지 이벤트를 구독하고 필요할 때 작업을 수행하게 하면 됩니다. 
  * 역시나, 이 방법에도 단점이 존재하는데, 아래 그림에서 구독이라는 쓰여져있는 부분으로 비지니스 프로세스의 명확한 뷰가 암시적으로 반영되는 단점이 존재합니다.

<br>

**MSA의 장점**

1️⃣ **첫째**, 서비스별 시스템이 독립적으로 구성되어 있어, 그만큼 하나의 기능을 개발할 때 봐야할 코드의 수도 적으며, **이해하기 쉽다**. 즉 적고 작은 만큼 **유지보수하기 쉽다.**

2️⃣ **둘째**, 서비스가 독립적으로 나눠져 있어, 하나의 서비스에 문제는 하나의 서비스만 수정하여 빌드 및 배포하면 되므로 **상대적으로 빌드 및 배포가 빠르다.**

3️⃣ **셋째**, 각 기능에 맞는 **언어와 프레임워크를 선택할 수 있다.**

<br>

**MSA의 단점**

1️⃣ **첫째**, 여러 모듈들이 분산되어 있어 **관리 및 모니터링이 힘들다.**

2️⃣ **둘째**,시스템이 커질수록 각각의 서비스가 독립적인 서비스이긴 힘들다. 즉, A 서비스가 B 서비스의 코드를 호출할 수 있는데 이 부분은 모놀리식과 비교하였을 때 어렵다.

→ 모놀리식일 경운 단순히 같은 시스템 내부에서의 method 호출,

→ but, MSA 일 경우, http 통신 등을 통해 호출해야 한다.

3️⃣ **셋째**,모듈별로 애플리케이션과 통신하므로 **다양한 통신에서 발생하는 오류가 상대적으로 잦다.**

4️⃣ **넷째**,하나의 시스템의 동작을 모두 확인하는 통합 테스트를 End-to-End로 진행하기 위해선 각각의 마이크로 모듈들과 UI, Gateway를 구동시켜야 한다. 즉, **상대적으로 통합테스트 하기 어렵다.**

---

### 미들웨어

<br>

**RPC**

* 정의
  * 원격 프로시저 호출(영어: remote procedure call, 리모트 프로시저 콜, RPC)은 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.
  * 일반적으로 프로세스는 자신의 주소공간안에 존재하는 함수를 호출하여 실행가능하지만, RPC를 이용하면 다른 주소공간에서 동작하는 프로세스의 함수를 실행할 수 있게 된다.
* 왜?
  * 현재 유행하는 `MSA(Micro Service Architecture)` 구조로 서비스를 만들다보면, 다양한 언어와 프레임워크로 개발되는 경우가 잦음. 이런 `Polyglot` 한 구조에서는 프로토콜(Socket)을 맞춰서 통신해야 하는 비용이 발생한다.
  * **통신 관련 문제를 신경 쓰지 않고 원격지의 함수를 마치 로컬의 함수처럼 쓴다**는 것이 큰 장점이다. 특히, **IDL(Interface Definication Language)** 기반으로 다양한 언어를 가진 환경에서도 쉽게 확장이 가능
  * 이 경우에 RPC를 이용하여 언어에 구애받지 않고, 원격에 있는 프로시저를 호출하여 조금 더 비즈니스 로직에 집중하는 개발을 할 수 있다.

<br>

**ORB(Obejct Request Broker)**

* **객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현**한 미들웨어

<br>

**MOM (Message Oriented Middleware)**

- 메시지 기반의 **비동기형 메시지를 전달**하는 방식의 미들웨어

- 메세지 지향 시스템이란 메세지 API를 통해 각 분산되어있는 애플리케이션간의 다리역할을 함으로써 데이터를 교환할 수 있도록 하는 시스템이다.

- 메세지를 통해 여러 분산되어 있는 시스템간의 Connector 역할로 결합성을 낮추고, 이들이 서로 실시간 비동기식 데이터를 교환할 수 있도록 하는 소프트웨어이다.

  > * 대규모 엔터프라이즈 시스템을 구축할 때 중요한 기술이며, 서로 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기위한 접착제 같은 역할을 한다.
  > * 기본적으로 느슨한 결합의 비동기 기술이며, 동기화 미들웨어 기술과는 다르게 CORBA에서 볼 수 있는 것처럼 수신측과 통신측이 강하게 결합되어 있지 않다.

<br>

**TP-Monitor**

* TP-Monitor는 항공기나 철도 **예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시**하는 미들웨어
* 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용
* 오라클의 tuxedo, 티맥스소프트의 tmax

---



