# SW공학/아키텍처

<br>

### 아키텍처

* 설계과정
  1. 설계 목표 설정 : 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
  2. 시스템 타입 설정 : 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
  3. 스타일 적용 및 커스터마이즈(아키텍처 패턴 적용) : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계
  4. 서브시스템 기능, 인터페이스 작성 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의
  5. 아키텍처 설계 검토
* 시스템 타입의 종류
  * **대화형** 시스템 : 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템
  * **이벤트 중심** 시스템 :은 외부의 상태에 따라서 변화를 주어 동작하는 시스템
  * **변환형** 시스템 : 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
  * **객체 영속형** 시스템 : 데이터 베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템

---

### 시스템통합

![image](https://user-images.githubusercontent.com/75229881/124056884-800dc100-da61-11eb-9e6c-7cfde3565d64.png)

**모놀리식 아키텍처**

* UI 및 비즈니스 로직, 데이터베이스 액세스 로직 모두가 하나의 애플리케이션 산출물로 패키징되고 애플리케이션 서버에 배포되는 것 (단일 코드 베이스)

**시스템통합 문제**

* 메인 프레임 시대에서 유닉스 시스템으로 내려오면서 부터 시스템들은 업무 단위로 분리가 되기 시작했다. ERP,CRM 등과 같은 시스템으로, 은행은 대내,대외,정보계와 같이 시스템으로 잘게 잘게 나눠지기 시작했는데, 당연히 이렇게 나눠진 시스템 사이에는 통신이 필요하게 되었고, 시스템이 거대화 되가면서, 시스템간에 직접 P2P로 통신하는 구조는 한계에 다다르기 시작하였다

**EAI (Enterprise Application Integration)**

* EAI의 가장 큰 특징은 표준화 되지 않은 이기종 시스템간의 연동을 가능하게 해준다는 것이다. 메인프레임 → Unix ERP 시스템으로 데이타를 전송하게 한다던지 Oracle → CRM 시스템으로 데이타를 전송해주는 것과 같은 시스템 통합을 지원했는데, 이는 이기종간에 통신 프로토콜이나 통합 방식을 변경할 수 있는 어댑터를 제공하기 때문이다

**SOA/ESB**

* 이 기종간의 통합이 많아지고, 시스템이 점점 분리되다 보니, 아예 이를 표준화하고자 하는 작업이 진행되었는데, 이것이 바로 SOA (Service Oriented Archtiecture / 서비스 지향 아키텍쳐)이다. (마이크로서비스)
* 웹서비스 기반으로 통신이 표준화(SOAP)되었기 때문에 서비스간의 통신은 EAI처럼 별도의 어댑터가 필요 없어졌다. 대신 서비스간의 통신을 서비스 버스(ESB)라는 통신 백본을 이용하여 통신을 하는 구조가 되었다.

---

### EAI 구축유형

![image](https://user-images.githubusercontent.com/75229881/126605344-79da9988-1f93-4fee-adf5-1e8907eb1890.png)

---

### 아키텍처 패턴

**계층형 패턴**

> - **Presentation layer:** UI, 브라우저에서의 유저와의 통신 로직을 다룸.
> - **Business layer:** 요청에 따른 비즈니스 로직을 다룸.
> - **Persistence layer:** DAO(Data Access Object) , ORM과 관련된 데이터베이스에 접근해서 데이터를 저장, 수정하는 함수 로직을 다룸.
> - **Database layer:** 데이터가 다 저장되어있는 곳. 데이터베이스.

<img src = "https://user-images.githubusercontent.com/75229881/163995684-1651269c-27eb-4767-81ef-6ca6eb3c56c6.png" width="50%">

**장점**

- 시스템 분석이 용이함
- 변화에 대한 영향력을 한정할 수 있어 코딩이나 테스트를 계층별로 진행할 수 있음
- 계층간 구조를 나누어 재사용성이 높음

**단점**

- 계층을 구분하기 어렵고 잘못 구분할 경우 수정이 빈번할 수 있음
- 또한 설계시 계층의 개수 및 규모를 정하기 어려움

<br>

**클라이언트-서버 패턴**

**마스터-슬레이브 패턴**

<img src = "https://user-images.githubusercontent.com/75229881/151334550-707f5967-24aa-49dc-8ed5-4fcd5fffdddb.png" width="60%">

* 실시간 시스템에서 사용
* 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업 분할 -> 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식

**파이프-필터 패턴**

![image](https://user-images.githubusercontent.com/75229881/141670795-d99674af-9d16-44c8-a722-d6be6a8f26d2.png)

* 데이터 스트림 절차의 **각 단계를 필터 컴포넌트로 캡슐화**하여 파이프를 통해 데이터를 전송하는 패턴
* 필터 컴포넌트는 재사용성 좋고 추가가 쉬워 확장이 용이
* 데이터 변환, 버퍼링, 동기화 등에 사용됨
* 대표적으로 Unix의 쉘 방식

**브로커 패턴**

<img src = "https://user-images.githubusercontent.com/75229881/141670826-527a657b-4dfa-4327-87f8-c1a116817659.png" width="60%">

* 이 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호 작용을 할 수 있다. 브로커(broker) 컴포넌트는 컴포넌트(components)간의 통신을 조정하는 역할을 한다.

---

### N-계층구조

**2-Tier 구조**

* **2 - 계층 구조(two-tier archtecture)**에서는 응용 프로그램이 클라이언트 상에 존재하며 질의문을 보냄으로써 서버에 있는 데이터베이스 시스템의 기능을 불러온다. 이때 클라이언트와 서버 사이의 교신을 위해 **ODBC** 나 **JDBC** 와 같응 응용 프로그램 인터페이스 표준이 사용된다.

**3-Tier 구조**

* **3-계층 구조(three-tier architecture)**에서 클라이언트는 어떤 데이터베이스 호출도 직접적으로 수행하지 않고 단지 전처리 시스템으로서의 역할만 한다. 대신, 클라이언트와 **응용 프로그램 서버(application server)** 사이의 교신은 대개 폼 인터페이스를 통해서 이루어진다. 다음으로, 응용 프로그램 서버는 데이터에 액세스하기 위해 데이터베이스 시스템과 통신한다. 
* 어떤 행동(action)이 어떠한 조건 하에서 수행되는지를 가리키는 **비즈니스 로직(business logic)**은 여러 클라이언트에 분산되어 있는 것이 아니라 응용 프로그램 서버 쪽에 포함되어 있다. 3-계층 구조는 world wide web 이나 대규모의 응용 프로그램에 보다 적합하다.

---

### 4+1 view

![image](https://user-images.githubusercontent.com/75229881/161049606-178ebe86-3729-4d9f-8c1e-9c244ca2771c.png)

**Use Case View**

* **사용자**, 설계자, 개발자 및 테스터의 관점
* 주로 **UseCase Diagram, Activity Diagram**으로 표현 

**Logical View**

* **설계자와 개발자 관점**
* 시스템 내부를 조망하고 시스템의 기능성이 어떻게 제공되는지 설명
* 정적 구조와 동적 구조를 다룸
  - 정적 구조: 클래스, 객체, 관계(Class Diagram, Object Diagram)
  - 동적 구조: 객체가 다른 객체에게 메시지를 전달할 때 발생하는 협동구조
* 클래스, 패키지, 컴포지트, 상태 다이어그램 등

**Process View**

* **개발자와 시스템 통합자 관점**
* 프로세스와 프로세서로 구분되는 시스템의 분할을 설명
* 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행 및 비동기, 이벤트의 처리 등
* 시퀀스, 통신, 액티비티 다이어그램 등

**Implement View**

* 구현 모듈과의 의존성 표현
* 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
* 컴포넌트 다이어그램

**Deployment View**

* **개발자, 시스템 통합자 및 테스터 관점**
* 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 맵핑
* 배포 다이어그램

---

