# 소프트웨어공학/객체지향

<br>

### 캡슐화

* 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.
* **코드의 재사용 및 효율성이 증가**

* **정보은닉과 캡슐화의 차이**

|     ＼      |                 정보은닉(Information hiding)                 |                    캡슐화(Encapsulation)                     |
| :---------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    개념     | **데이터 캡슐화가 아닌 외부에 감춰야하는 비밀에 따라 시스템을 분할하는 모듈 분할의 원리**  <br />잘 정의되고 쉽게 변경되지않는 공용 인터페이스를 외부에 제공하여 내부의 비밀에 함부로 접근할 수 없도록 하는 것 | ***** 데이터를 공용 메소드를 통해서만 접근 허용(= 데이터 캡슐화) |
| 숨기는 내용 |  캡슐 내의 요소들에 대한 세부 구현사항들을 외부로부터 숨김   | 관련된 요소들을 묶음으로써 캡슐 내부와 외부를 구별지어 특정 객체 속에 있는 데이터와 함수들을 다른 객체 속에 있는 데이터와 함수들과 구별이 이뤄짐 |
|    결론     | 정보은닉의 개념이 캡슐화 개념안에 포함되기 하지만, 캡슐화가 되어있다고 해서 반드시 정보은닉이 되는 것이 아니다. |                                                              |

* 캡슐화를 통한 정보은닉(Information hiding)의 장점

```
1. 객체에 포함된 정보의 손상과 오용을 막을 수 있다. 정보은닉은 단어 자체로 정보를 숨기는 것이기 때문에 권한이 없는 외부의 객체가 접근할 수 없기 때문에 정보 손상이 발생하지않는다. 

2. 객체의 사용방법은 바뀌지않는다. 정보은닉된 객체의 인터페이스만으로 접근하기 때문에 내부 조작 방법이 바뀌어도 접근방법이 변경되진않는다. 

3. 데이터가 바뀌어도 다른 객체에 영향을 주지않아서 독립성이 유지된다. 

4. 객체의 이식성이 좋다. 객체의 정보에 직접적인 접근이 아닌, 연산만을 통한 접근이다. 그렇기에 연산으로 출력된 결과물만 사용하므로써 객체의 이식성이 높아진다. 

5. 객체를 시스템 구성에서 부품처럼 사용할 수 있다. 연산으로 인해 출력된 결과물만 사용하기 때문에 객체를 부품화 할 수 있다. 부품화된 객체를 새로운 시스템 구성에서 부품처럼 사용이 가능하다. 
```

---

### SOLID

**SRP(Single Responsibility Principle)**

* 클래스는 하나의 기능만을 가져야 한다.
* 응집도는 높고 결합도는 낮은 프로그램을 설계한다.

**OCP(Open Closed Principle)**

* 기존의 코드를 수정하지 않고(Closed) 새로운 기능을 추가(Open)할 수 있도록 설계한다.
* 이를 위해 자주 사용되는 문법이 인터페이스(Interface)이다.
* 이와 같은 설계를 디자인 패턴에서는 Strategy Pattern(전략 패턴)이라고 한다.

**LSP(Liskov Substitution Principle)**

* 자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.

**ISP(Interface Segregation Principle)**

> [[SOLID\] 인터페이스 분리 원칙(ISP)이란? (tistory.com)](https://steady-coding.tistory.com/385)

* 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.

**DIP(Dependency Inversion Principle)**

* 의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다.
* DIP를 만족한다는 것은 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미한다.
* DIP를 만족하면 '**의존성 주입**' 이라는 기술로 변화에 유연한 설계를 할 수 있다.

---

### GoF 디자인 패턴

<img src = "https://user-images.githubusercontent.com/75229881/151336468-70f31d5f-9e31-4f9b-be00-6642d7705137.png" width="80%">

#### 1. 생성패턴

#### 2. 구조패턴

#### 3. 행위패턴

**3.1 스트레티지 패턴**

* 스트래티지 패턴에서는 알고리즘군을 정의하고 각각을 **캡슐화**하여 교환해서 사용할 수 있도록 만든다. 
* 스트래티지를 활용하면 알고리즘을 사용하는 **클라이언트와는 독립적으로 알고리즘을 변경**할 수 있다.
* 즉, **행위를 클래스로 캡슐화** 하여 동적으로 행위를 바꾸어도 코드가 복잡해 지지 않도록 한다.
* 예시로, Duck 이라는 **클래스**에 Fly, QuakBehavior이라는 **행위를 인터페이스**로 구현
* Duck이 아니더라도 참새클래스에 Fly 등의 **행위를 주입**할 수 있다.

**3.2 커맨드 패턴**

* 스트레티지(**어떻게?**) / 커맨드(**무엇을?**)
  * 수신자(Receiver) : 행동을 담당하는 객체 = 기능을 수행 ex) Music on/off
  * 커맨드(Command) : 수신자의 정보 + 행동이 들어있는 객체 ex) Remote Controller 
  * 발동자(Invoker) : 커맨드를 저장하는 객체 -> 버튼이 어떤 수행을 할 것인지 결정 ex) button_click
  * 클라이언트(Client) : 커맨드 객체를 생성하고, 발동자를 통해 수신자에게 할 행동을 결정함

---

