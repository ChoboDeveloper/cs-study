# 소프트웨어 공학

<br/>

### SW 생명주기(개발단계)

**1. 계획**

* 타당성 검토 후, 개발에 필요한 자원을 산출하고 장소, 인력, 기간 등 대략적인 계획을 수립한다.
* 간트 차트, CPM, FP 점수 등 활용
* 비용산정방식
  * FP
    * 트랜잭션 타입
      * EI(외부입력), EO(외부출력), EQ(외부조회)
    * 데이터 타입
      * ILF(내부논리파일) : 산정 대상 시스템이 유지/관리하는 파일
      * ELF(외부연계파일) : 산정 대상 시스템이 참조하는 파일
    * 데이터 기능(RET, DET)
    * 트랜잭션 기능(트랜잭션 FTR, DET)
    * RET(Record Element Type) ≒ 테이블 수
    * DET(Data Element Type) ≒ 고유 칼럼 수
    * FTR(File Type Reference) ≒ 연계되는 테이블 수

<Br>

**2. 요구사항 분석**

* 2.1 요구사항 도출(Elicitation)
* 2.2 요구사항 분석(Analysis)
  * 도메인 분석
    * 어떠한 프로세스, 클래스 등에서 명칭, 타입, 설명 등 비즈니스에서 시스템이 필요한 요소를 분석하는 작업
    * 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.
* 2.3 요구사항 명세(Specification)
* 2.4 요구사항 검토(Validation)
  * 동료검토 : 작성자가 명세서 내용 설명 동료들이 결함 발견하는 형태
  * 워크스루 : 검토 회의 전 **명세서를 미리 배포**하여 사전 검토 후 짧은 검토 회의를 통해 오류 조기 검출
  * 인스펙션 : 명세서 **작성자를 제외**한 다른 검토 전문가들이 확인하면서 결함을 발견하는 형태

<Br>

* **요구공학**

  * 시스템이 제공하여야 할 서비스나 제약 조건을 포괄적으로 기술한 것부터 수학 기호로 자세히 표현한 

    것까지 다양함

  * 사용자 요구 

    * 시스템이 제공할 서비스와 수행될 때의 제약 조건을 그림이나 글로 표현한 것 
    * 사용자를 위하여 작성 

  * 시스템 요구

    * 시스템이 제공하여야 할 서비스를 체계적으로 자세히 적은 것 
    * 계약자와 개발자 사이의 계약 

  * 소프트웨어 명세

    * 개발될 소프트웨어에 대하여 기술한 것으로 설계와 구현에 기초가 됨 
    * 개발자를 위하여 작성 

* **분석도구**

  * Mini-spec, E-R Diagram, Data Dictionary, DFD 등

* **구조적 분석(DFD)**

  * 사용자의 요구분석 사항을 파악하기 위하여 자료의 흐름과 가공절차를 그림 중심으로 표현하는 방법 
  * 처리중심(Process-Oriented) 분석기법
  * 순서
    1. 배경도 작성 
    2. 상위 자료 흐름도 작성 
    3. 하위 자료 흐름도 작성 
    4. 자료 사전 작성 
    5. 소단위 명세서 작성
  * 특징
    * 그림 중심의 표현 
    * 하향식(Top-Down Partitioning) 원리를 적용 
    * 사용자의 업무 요구 사항을 쉽게 문서화 
    * 사용자 분석자 간의 의사소통을 위한 공용어 
    * 실체의 모형(추상적 표현)을 추출 

* **객체지향 분석**

  * 순서
    1. 기본 데이터로 객체를 중심으로 수행 
    2. 객체의 구조, 기능, 동작의 3가지 측면으로 구체화
    3. 이들은 정적인 클래스 구조, 객체 사이의 상호작용, 객체 내부의 행동들을 표시
  * 객체지향 요구분석
    1. 객체 찾기 
       * 엔티티 객체, 경계 객체, 제어 객체를 찾음 
    2. 객체 사이의 상호 작용 모형화 
       * 사용사례에 작성된 객체 사이의 상호작용을 순서 
       * 다이어그램이나 협동 다이어그램으로 작성 
    3. 객체 사이의 연관관계 찾기
       * 객체 사이의 여러 가지 관계를 찾아 **클래스 다이어그램**을 작성 
    4. 객체 속성 찾기 
       * 객체 안에 있어야 할 속성들을 파악
    5. 상태 다이어그램 작성 
       * 난해한 동작은 상태 다이어그램으로 모형화
    6. 분석 모형 검토 
       * 분석 모형 사이에 모순이 없는지 확인하고 빠진 것이 없는지 검토

<br>

**3. 설계**

* 상향식 설계
  * 부품을 자세히 설계하고 그것들 조합하여 전체 시스템 구성
* 하향식 설계
  * 부품을 자세히 설계하고 그것들 조합하여 전체 시스템 구성
  * **HIPO 차트**

<br>

**4. 구현**

<br>

**5. 테스트**

* 검증
  * 소프트웨어가 요구사항에 부합하게 구현
  * 소프트웨어 **개발 과정**을 테스트(개발자 시점)
* 확인
  * 소프트웨어 **결과**를 테스트(사용자 시점)

<br>

**6. 유지보수**

* 수정 유지보수
  * 하자보수
* 적응 유지보수
  * 환경변화에 적응(OS, HW 등)
* 완전 유지보수
  * 새로운 기능을 추가
  * 확장 및 리모델링
* 예방 유지보수
  * 잠재적인 오류발생 대비

<br>

**SDLC의 종류**

* 폭포수

* 프로토타입

  * 프로토타입을 만들어 고객과 사용자가 함께 평가한 후 개발될 소프트웨어의 요구사항을 정제하여 보다 완전한 요구명세서를 완성하는 방식
  * 개발과정에서 사용자의 요구를 충분히 반영한다.
  * 최종결과물이 만들어지기 전에 의뢰자가 최종결과물의 일부 혹은 모형을 볼 수 있다.

* 나선형

  * 대규모 시스템 개발
  * 프로젝트 수행시 발생하는 위험을 관리하고 최소화하기 위한 방식
  * **계획 수립 - 위험 분석 - 개발 및 검증 - 고객평가** 순으로 반복

* UP

  * 통합 프로세스 모델의 개발 과정은 크게 4단계(도입, 구체화, 구축, 전이)로 나뉘고 각 단계도 여러 개의 작은 단위(반복, iteration)로 나뉘어 각 반복 구간을 하나씩 실행한다.

    * ex) 각 작업을 반복 수행. 구체화(elaboration, 정련, 상세)와 전이 단계는 2회씩, 구축 단계는 3회 이상 반복.
    * 객체지향 분석/설계 중심의 프로젝트에서 많이 사용되는 대표적인 반복적/점증적 프로세스

    * 비즈니스 관점에 초점을 맞춘 프로세스
    * 도입
      * 비즈니스 케이스를 구축하며 시스템이 당면 문제를 알아낸다.
      * 비즈니스 모델, 비전문서, 프로토타입을 생성한다.
    * 구체화
      * 프로젝트를 계획하고, 시스템의 기능과 구조를 정의한다.
      * 유스케이스 모델과 실행 가능한 기본 구조를 생성
      * 아키텍처 결정을 위한 설계 작업과 분석 작업의 비중이 크고, 시스템 구성에 관련된 위험 요소를 식별하고 완화하는데 중점
    * 구축
      * 아키텍처에서 발생한 설계는 필요에 따라 테스트되고, 리팩토링된다.
      * 각 반복을 통해 객관적으로 평가될 수 있는 실행 가능한 코드가 나온다.
    * 전이
      * 테스트 후 사용자에게 인도된다.

* Scrum

  * **제품 백로그(Product Backlog)** : 개발할 제품의 요구사항인 사용자 스토리 집합이며, 우선순위로 관리(제품기능목록)
  * **사용자 스토리(User Story)** : 과거 요구사항 명세처럼 업무 범위를 구체화하기 위한 개발자 입장이 아닌, User Story는 사용자가 사용하는 관점에서 어떤 가치를 제공할 것인지를 설명
  * **스토리 포인트 :** 일반적인 소프트웨어 개발에서는 개발에 소요되는 시간을 일, 주, 개월과 같은 시간 단위로 예측
  * 완료 기준(Definition of Done), 인수 기준(Acceptance Criteria) : 사용자 스토리를 완료시키기 위한 조건 명세(Given, When, Then)
  * **스프린트(Sprint) :** 계획,개발,리뷰 작업 등 최소 단위의 Cycle이다. 보통 1~4주 단위에서 선택
  * 잠재적 출시 가능 제품(Potentially Shippable Product Increment) 또는 최소 실행 가능 제품(Minimum Viable Product, MVP) : 팀이 최소 노력으로 고객에게 검증 결과를 받을 수 있는 수준의 제품
  * **스프린트 계획 회의(Sprint Planning Meeting) :** 스프린트 목표와 스프린트 백로그를 계획하는 회의(4주 스프린트 기준 8시간 정도 수행)
  * **스프린트 백로그(Sprint Backlog) :** 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록
  * **소멸 차트 :** 개발을 완료하기까지 남은 작업량을 보여주는 그래프 
  * 칸반 보드(Kanban Board) : 작업을 시각적으로 업무 상태, 흐름을 보여주는 게시판
  * 일일 스크럼 회의(Daily Scrum Meeting) : 매일 어제 한일, 오늘 할일, 해결해야 할 장애/문제 요소를 공유하는 회의(매일 15분 정도 수행)
  * **스프린트 리뷰(Sprint Review)** : 스프린트 마지막날 개발자가 개발한 내용을 Stakeholder, 고객, 제품 책임자에게 시연하고 검토(4주 스프린트 기준 4시간 정도 수행)
  * **스프린트 회고(Sprint Retrospective)** : 스프린트 마지막날 좋았던 점, 개선할 점을 도출하고 더 나은 방향으로 개선(4주 스프린트 기준 3시간 정도 수행)

---

### 결합도

> "자스제외공내"

**자료 결합도**

* 모듈간의 인터페이스 전달되는 파라미터를 통해서만 모듈간의 상호 작용이 일어나는 경우
* 깔끔한 **Call by value**

**스탬프 결합도**

* 모듈간의 인터페이스로 배열이나 **오브젝트, 스트럭쳐**등이 전달되는 경우

**제어 결합도**

* 단순히 처리를 해야할 대상인 값만 전달되는게 아니라 어떻게 처리를 해야 한다는 **제어 요소(DCD, Flag등)이 전달**되는 경우.

**외부 결합도**

* 어떤 모듈에서 **반환한 값**을 다른 모듈에서 참조

**공통 결합도**

* 파라미터가 아닌 모듈 밖에 선언되어 있는 **전역 변수**를 참조

**내용 결합도**

* 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용

---

### 응집도

> "우논시절교순기"

**우연적 응집도**

* 모듈 내부의 각 구성요소들이 연관이 없을 경우

**논리적 응집도**

* 실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우

**시간적 응집도**

* 연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우

**절차적 응집도**

* 모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우

  ```
  (예시)
  - 화면을 지우고 팝업창을 띄우는 모듈
  ```

**교환적(통신적) 응집도**

* 서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우

* 같은 입력자료를 이용하거나 동일 출력 데이터를 만들어내는 경우

  ```
  (예시)
  - Employee라는 클래스의 데이터를 조작, 저장 갱신하는 모듈
  ```

**순차적 응집도**

* 모듈 안의 하나의 소작업의 결과가 다음 작업의 입력이 되는 경우

  ```
  (예시)
  - 다음 트랜잭션을 읽고 마스터 파일을 변경함
  - 합수 집합을 받아 미지수를 풀어내는 함수
  ```

**기능적 응집도**

* 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

---

### UML

| **구조**               | **행위**                   |
| ---------------------- | -------------------------- |
| 클래스 다이어그램      | 시퀀스 다이어그램          |
| 객체 다이어그램        | 액티비티 다이어그램        |
| 배치 다이어그램        | 상태 다이어그램            |
| 컴포지트 다이어그램    | 유스케이스 다이어그램      |
| 패키지 다이어그램      | 타이밍 다이어그램          |
| 복합체 구조 다이어그램 | 커뮤니케이션 다이어그램    |
|                        | 인터렉션 오버뷰 다이어그램 |

#### 1. 구조

**1.1 클래스 다이어그램**

* 연관(Association)
  * **Association은 다른 객체의 참조를 가지는 필드**를 의미
* 의존
  * Dependency는 클래스간의 참조가 일어나는 것
  * Dependency 참조는 메서드 내에서 대상 클래스의 객체를 생성하거나 사용, 리턴받아 사용하는 것
  * 즉, **멤버변수로 사용하지 않고 파라미터, 지역변수**로 활용하는 것을 의미
* 일반화(Generalization)
  * 상속을 의미
* 실체화(Realization)
  * Realization은 interface에 있는 spec을 오버라이딩하여 실제로 구현하는 것

#### 2. 행위

**2.7 인터렉션 오버뷰 다이어그램**

* **시퀀스 다이어그램 + 액티비티 다이어그램**

---

### UML 확장모델

|              종류               | 설명                                                         |
| :-----------------------------: | :----------------------------------------------------------- |
| **스테레오 타입 (Stereotypes)** | UML 의 기본적인 요소 이외의 새로운 요소 만들어 내기 위한 확장 메커니즘이다. 형태는 기존의 UML 의 요소를 그대로 사용하나 내부의미는 다른 목적으로 사용하도록 확장한다. **스테레오 타입 객체는 << >> 기호**를 사용하여 표현한다. |
|   **꼬리표값(Tagged values)**   | UML 구성 요소가 갖는 속성을 확장하여 구성요소의 명세서에 새로운 정보를 추가하기 위한 메커니즘이다. **{tag=value}** 기호를 사용하여 표현한다. |
|      **제약(Constraints)**      | UML 구성 요소에 있는 이전의 규칙을 수정하거나 새롭게 생성하기 위한 메커니즘이다. **{} 기호를 사용**하여 표현한다. |

---

### 객체지향 분석

**럼바우 기법**

* 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(Object Modeling Technique) 라고도 한다.

* **객체 모델링**
  * 객체 관계
  * **E-R 다이어그램**

* **동적 모델링**
  * 시간의 흐름
  * **상태도**

* **기능 모델링**
  * 자료의 흐름
  * **자료 흐름도**

<br>

**객체지향 분석 방법론**

```c++
// Booch(부치) 방법
미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 
클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다

// Jacobson 방법
Use Case를 강조하여 사용하는 분석 방법이다.

// Coad와 Yourdon 방법
E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 
인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법

// Wirfs-Brock 방법
분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법 
```

---

### DFD

* DFD 는 데이터의 흐름을 나타내는 그림이다.
* Process(원), Data Flow(화살표), Data Store(=), External Entity(사각형)으로 구성
  * External Entity : 프로세스 처리 과정의 데이터 발생의 시작 및 종료를 나타낸다. 사람, 부서, 기능 등이 될 수 있음 
* 7가지 원칙
  * 자료 보존
  * 최소 자료 입력
  * 순차 처리
  * 독립성
  * 지속성
  * 영구성
  * 자료 변환
---

### UP

* 점진적 개발 프로세스 모델
* 유스케이스 기반, 아키텍쳐 중심 개발 모델

---

### 3R

> 완성된 소프트웨어 프로그램을 기반으로 역공학(Reverse-Engineering), 재공학(Re-Engineering), 재사용(Re-Use)를 통해 소프트웨어의 생산성을 극대화 하는 기법

- **역공학(Reverse-Engineering)**
  - 기존 개발된 시스템을 CASE를 이용하여 사양서, 설계서 등의 문서로 추출하는 작업
  - 소스 코드 -> 문서화
  - 개발 단계를 역으로 올라가 기존 개발된 시스템의 코드나 데이터로부터 설계 명세서나 요구 분석서 등을 도출하는 작업
- **재공학(Re-Engineering)**
  - 기조 시스템을 널리 사용되는 프로그래밍 표준에 맞추거나 고수준의 언어로 재구성하거나 타 하드웨어에서 사용할 수 있도록 변환하는 작업
  - 소프트웨어의 위기를 해결하기 위해 개발의 생산성이 아닌 유지 보수의 생산성으로 해결하려는 방법
- **재사용(Re-Use)**
  - 이미 개발되어 기능, 성능, 품질을 인정받았던 소프트웨어의 전체 또는 일부분을 다시 사용
  - 다른 시스템에 이용되고 있는 소프트웨어를 파악하고 재구성하여 새로운 시스템에 적용하기 위한 작업

---

### 아키텍처

> SW 컴포넌트들의 관계를 정의한 시스템 구조

* 간략성, 추상화, 가시성
* 핵심은 비기능적 요구사항
  * 변경용이성
    *  소프트웨어를 쉽게 수정/확장/재조직하거나 다른 플랫폼으로 이식 할 수 있는지 등의 능력
  * 상호운용성
    * 소프트웨어가 다른 소프트웨어와 정보를 주고 받을 수 있는 능력
  * 효율성
  * 신뢰성
    * 결함 허용력/견고함
  * 테스트용이성
  * 재사용성

---

### 형상관리

> 소프트웨어의 변경사항을 추적하고 통제하는 행위

* 형상관리의 구조
  * 형상 식별
    * 형상 관리의 대상이 무엇인지 식별하는 것
    * 식별 대상을 형상 항목(configuration item) 이라고 한다.
  * 형상 통제
    * 형상 항목의 버전(version control)과 변경에 대한 판단을 내리는 것
  * 형상 감사
    * 요구대로 형상 항목의 변경이 제대로 이뤄졌는지 살펴보는 것
  * 형상 상태 보고
    * 변경된 형상 항목을 관계된 사람들에게 알리는 것
* 형상관리 도구
  * CVS, SVN, Git, Perforce

---

### SW 개발 방법

* 비교

| 항목      | 정보공학                                                     | 객체지향                                                     | CBD                                                          |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 주요관점  | 데이터 중심                                                  | 객체 중심                                                    | 컴포넌트 중심                                                |
| SDLC 모델 | 폭포수 모델                                                  | 반복적 개발 모델                                             | 반복적 개발 모델                                             |
| 주요기술  | PC보급 확산                                                  | 인터넷 이용확산                                              | 비즈니스 기능 단위 컴포넌트                                  |
| 환경      | 전사규모의 정보시스템<br/>관계형DB                           | 다양한 SW요구증대<br/>객체지향 언어                          |                                                              |
| 주요기법  | 데이터모형(객체 관계도),정보전략계획, BRP, 분산설계          | 객체모형위험관리반복적/점진적개발분석/설계 패턴설계개선(Refactoring) | 컴포넌트 명세컴포넌트 추출컴포넌트 연동컴포넌트 설계         |
| 특징      | 안정된 개발방법론                                            | 실세계 개념 모형<br/>UML 사용 확산                           | 적기 개발개발비용 감소                                       |
| 장점      | 데이터 관점의 정규화 산출물이 단계별로 명확함, 대규모, 잘 알려진 프로젝트 적용 | 경험이 없는 프로젝트에 유용, 재사용성을 증대, 객체중심 개발, 의사소통 유리 | 컴포넌트 조립으로 개발, 생산성 향상, Time To Market 실현     |
| 단점      | 웹 환경에 적용 어려움, 분산환경, 컴포넌트 실행환경에 적용 어려움 | 대규모 프로젝트 적용 어려움, 성숙한 객체기술자 필요          | 조직에 따라 적용 가능한 컴포넌트 기술 수준이 다름, 업종별 특성을 지닌 컴포넌트 부족 |

---

### 요구사항

* 기능적 요구사항
  * 시스템에 주어지는 특정 입력에 대한 시스템이 산출하는 출력을 통해 정의
  * 시스템 기능, 입력, 출력
* 비기능적 요구사항
  * 제품요구사항
    * 사용성, 효율성, 이식성, 신뢰성
  * 조직요구사항
    * 배포, 구현, 표준
  * 외부요구사항
    * 상호운용성 : 구현할 소프트웨어가 다른 소프트웨어와 어떻게 연동할지 정의 

---

### CASE

> Computer Aided Software Engineering
> (컴퓨터 지원 소프트웨어 공학)

**CASE의 원천기술**

* 구조적 기법
  * 하향식, 기능식 분할 방법을 이용하여 시스템의 요구를 정의하는 모델링 기법
* 프로토타이핑
  * 시제품 형태의 소프트웨어를 단기간에 제작하여 사용자에게 제시함으로써 요구사항을 확정하고 개발을 진행하여 완성한 소프트웨어에 대한 사용자의 만족도를 높임으로써 비용을 절감할 수 있음
  * 프로토타입용 프로그래밍 언어, 스크린 레이아웃 제작도구, 보고서 설계를 위한 도구가 포함되어 있다
* 자동 프로그래밍 기술
* 정보 저장소 기술
  * 소프트웨어를 개발하는 동안에 모아진 시스템에 관련된 정보를 보관하여 관리하는 곳이다
  * 정보 저장소에 저장하는 정보는 소프트웨어 요구 분석 및 설계서 등이 포함된다
* 분산처리 기술

---

### 프로젝트 일정계획

**순서**

1. SDLC를 정하고 프로젝트 규모를 측정
2. WBS를 작성하여 작업을 분할
3. 각 작업의 상호의존 관계를 CPM 네트워크로 구성
4. 일정 계획을 간트차트로 표현

---

