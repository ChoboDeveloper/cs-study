# 소프트웨어 공학

<br/>

### SW 생명주기(개발단계)

**1. 계획**

* 타당성 검토 후, 개발에 필요한 자원을 산출하고 장소, 인력, 기간 등 대략적인 계획을 수립한다.
* 간트 차트, CPM, FP 점수 등 활용
* 비용산정방식
  * FP
    * 트랜잭션 타입
      * EI(외부입력), EO(외부출력), EQ(외부조회)
    * 데이터 타입
      * ILF(내부논리파일) : 산정 대상 시스템이 유지/관리하는 파일
      * ELF(외부연계파일) : 산정 대상 시스템이 참조하는 파일
    * 데이터 기능(RET, DET)
    * 트랜잭션 기능(트랜잭션 FTR, DET)
    * RET(Record Element Type) ≒ 테이블 수
    * DET(Data Element Type) ≒ 고유 칼럼 수
    * FTR(File Type Reference) ≒ 연계되는 테이블 수

**2. 요구사항 분석**

* 2.1 요구사항 도출(Elicitation)
* 2.2 요구사항 분석(Analysis)
  * 도메인 분석
    * 어떠한 프로세스, 클래스 등에서 명칭, 타입, 설명 등 비즈니스에서 시스템이 필요한 요소를 분석하는 작업
    * 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.
* 2.3 요구사항 명세(Specification)
* 2.4 요구사항 검토(Validation)
  * 동료검토 : 작성자가 명세서 내용 설명 동료들이 결함 발견하는 형태
  * 워크스루 : 검토 회의 전 **명세서를 미리 배포**하여 사전 검토 후 짧은 검토 회의를 통해 오류 조기 검출
  * 인스펙션 : 명세서 **작성자를 제외**한 다른 검토 전문가들이 확인하면서 결함을 발견하는 형태

**3. 설계**

* 상향식 설계
  * 부품을 자세히 설계하고 그것들 조합하여 전체 시스템 구성
* 하향식 설계
  * 부품을 자세히 설계하고 그것들 조합하여 전체 시스템 구성
  * **HIPO 차트**

**4. 구현**

* 개발방법론
  * UP
    * 도입
      * 비즈니스 케이스를 구축하며 시스템이 당면 문제를 알아낸다.
      * 비즈니스 모델, 비전문서, 프로토타입을 생성한다.
    * 상세
      * 프로젝트를 계획하고, 시스템의 기능과 구조를 정의한다.
      * 유스케이스 모델과 실행 가능한 기본 구조를 생성
      * 아키텍처 결정을 위한 설계 작업과 분석 작업의 비중이 크고, 시스템 구성에 관련된 위험 요소를 식별하고 완화하는데 중점
    * 구축
      * 아키텍처에서 발생한 설계는 필요에 따라 테스트되고, 리팩토링된다.
      * 각 반복을 통해 객관적으로 평가될 수 있는 실행 가능한 코드가 나온다.
    * 이행
      * 테스트 후 사용자에게 인도된다.
  * XP

**5. 테스트**

* 검증
  * 소프트웨어가 요구사항에 부합하게 구현
  * 소프트웨어 **개발 과정**을 테스트
* 확인 
  * 소프트웨어 **결과**를 테스트

**6. 유지보수**

* 수정 유지보수
  * 하자보수
* 적응 유지보수
  * 환경변화에 적응(OS, HW 등)
* 완전 유지보수
  * 새로운 기능을 추가
  * 확장 및 리모델링
* 예방 유지보수
  * 잠재적인 오류발생 대비

---

### 결합도

> "자스제외공내"

**자료 결합도**

* 모듈간의 인터페이스 전달되는 파라미터를 통해서만 모듈간의 상호 작용이 일어나는 경우
* 깔끔한 **Call by value**

**스탬프 결합도**

* 모듈간의 인터페이스로 배열이나 **오브젝트, 스트럭쳐**등이 전달되는 경우

**제어 결합도**

* 단순히 처리를 해야할 대상인 값만 전달되는게 아니라 어떻게 처리를 해야 한다는 **제어 요소(DCD, Flag등)이 전달**되는 경우.

**외부 결합도**

* 어떤 모듈에서 **반환한 값**을 다른 모듈에서 참조

**공통 결합도**

* 파라미터가 아닌 모듈 밖에 선언되어 있는 **전역 변수**를 참조

**내용 결합도**

* 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용

---

### 응집도

> "우논시절교순기"

**우연적 응집도**

* 모듈 내부의 각 구성요소들이 연관이 없을 경우

**논리적 응집도**

* 실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우

**시간적 응집도**

* 연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우

**절차적 응집도**

* 모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우

**교환적(통신적) 응집도**

* 서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우
* 같은 입력자료를 이용하거나 동일 출력 데이터를 만들어내는 경우

**순차적 응집도**

* 모듈 안의 하나의 소작업의 결과가 다음 작업의 입력이 되는 경우
* 예를 들어, "다음 트랜잭션을 읽고 마스터 파일을 변경함"

**기능적 응집도**

* 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

---

### UML

| **구조**               | **행위**                   |
| ---------------------- | -------------------------- |
| 클래스 다이어그램      | 시퀀스 다이어그램          |
| 객체 다이어그램        | 액티비티 다이어그램        |
| 배치 다이어그램        | 상태 다이어그램            |
| 컴포지트 다이어그램    | 유스케이스 다이어그램      |
| 패키지 다이어그램      | 타이밍 다이어그램          |
| 복합체 구조 다이어그램 | 커뮤니케이션 다이어그램    |
|                        | 인터렉션 오버뷰 다이어그램 |

#### 1. 구조

**1.1 클래스 다이어그램**

* 연관(Association)
  * **Association은 다른 객체의 참조를 가지는 필드**를 의미
* 의존
  * Dependency는 클래스간의 참조가 일어나는 것
  * Dependency 참조는 메서드 내에서 대상 클래스의 객체를 생성하거나 사용, 리턴받아 사용하는 것
  * 즉, **멤버변수로 사용하지 않고 파라미터, 지역변수**로 활용하는 것을 의미
* 일반화(Generalization)
  * 상속을 의미
* 실체화(Realization)
  * Realization은 interface에 있는 spec을 오버라이딩하여 실제로 구현하는 것

#### 2. 행위

**2.7 인터렉션 오버뷰 다이어그램**

* **시퀀스 다이어그램 + 액티비티 다이어그램**

---

### UML 확장모델

|              종류               | 설명                                                         |
| :-----------------------------: | :----------------------------------------------------------- |
| **스테레오 타입 (Stereotypes)** | UML 의 기본적인 요소 이외의 새로운 요소 만들어 내기 위한 확장 메커니즘이다. 형태는 기존의 UML 의 요소를 그대로 사용하나 내부의미는 다른 목적으로 사용하도록 확장한다. **스테레오 타입 객체는 << >> 기호**를 사용하여 표현한다. |
|   **꼬리표값(Tagged values)**   | UML 구성 요소가 갖는 속성을 확장하여 구성요소의 명세서에 새로운 정보를 추가하기 위한 메커니즘이다. **{tag=value}** 기호를 사용하여 표현한다. |
|      **제약(Constraints)**      | UML 구성 요소에 있는 이전의 규칙을 수정하거나 새롭게 생성하기 위한 메커니즘이다. **{} 기호를 사용**하여 표현한다. |

---

### 객체지향 분석

**럼바우 기법**

* 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(Object Modeling Technique) 라고도 한다.

* **객체 모델링**
  * 객체 관계
  * **E-R 다이어그램**

* **동적 모델링**
  * 시간의 흐름
  * **상태도**

* **기능 모델링**
  * 자료의 흐름
  * **자료 흐름도**

<br>

> 객체지향 분석 방법론
>
> **Booch(부치) 방법**
> 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다
>
> **Jacobson 방법**
> Use Case를 강조하여 사용하는 분석 방법이다.
>
> **Coad와 Yourdon 방법**
> E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
>
> **Wirfs-Brock 방법**
> 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법 



---

### DFD

* DFD 는 데이터의 흐름을 나타내는 그림이다.
* Process(원), Data Flow(화살표), Data Store(=), External Entity(사각형)으로 구성
  * External Entity : 프로세스 처리 과정의 데이터 발생의 시작 및 종료를 나타낸다. 사람, 부서, 기능 등이 될 수 있음 
* 7가지 원칙
  * 자료 보존
  * 최소 자료 입력
  * 순차 처리
  * 독립성
  * 지속성
  * 영구성
  * 자료 변환
---

### UP

* 점진적 개발 프로세스 모델
* 유스케이스 기반, 아키텍쳐 중심 개발 모델

---

### 3R

> 완성된 소프트웨어 프로그램을 기반으로 역공학(Reverse-Engineering), 재공학(Re-Engineering), 재사용(Re-Use)를 통해 소프트웨어의 생산성을 극대화 하는 기법

- **역공학(Reverse-Engineering)**
  - 기존 개발된 시스템을 CASE를 이용하여 사양서, 설계서 등의 문서로 추출하는 작업
  - 소스 코드 -> 문서화
  - 개발 단계를 역으로 올라가 기존 개발된 시스템의 코드나 데이터로부터 설계 명세서나 요구 분석서 등을 도출하는 작업
- **재공학(Re-Engineering)**
  - 기조 시스템을 널리 사용되는 프로그래밍 표준에 맞추거나 고수준의 언어로 재구성하거나 타 하드웨어에서 사용할 수 있도록 변환하는 작업
  - 소프트웨어의 위기를 해결하기 위해 개발의 생산성이 아닌 유지 보수의 생산성으로 해결하려는 방법
- **재사용(Re-Use)**
  - 이미 개발되어 기능, 성능, 품질을 인정받았던 소프트웨어의 전체 또는 일부분을 다시 사용
  - 다른 시스템에 이용되고 있는 소프트웨어를 파악하고 재구성하여 새로운 시스템에 적용하기 위한 작업

---

### 아키텍처

> SW 컴포넌트들의 관계를 정의한 시스템 구조

* 간략성, 추상화, 가시성
* 핵심은 비기능적 요구사항
  * 변경용이성
    *  소프트웨어를 쉽게 수정/확장/재조직하거나 다른 플랫폼으로 이식 할 수 있는지 등의 능력
  * 상호운용성
    * 소프트웨어가 다른 소프트웨어와 정보를 주고 받을 수 있는 능력
  * 효율성
  * 신뢰성
    * 결함 허용력/견고함
  * 테스트용이성
  * 재사용성

---

### 형상관리

> 소프트웨어의 변경사항을 추적하고 통제하는 행위

* 형상관리의 구조
  * 형상 식별
    * 형상 관리의 대상이 무엇인지 식별하는 것
    * 식별 대상을 형상 항목(configuration item) 이라고 한다.
  * 형상 통제
    * 형상 항목의 버전(version control)과 변경에 대한 판단을 내리는 것
  * 형상 감사
    * 요구대로 형상 항목의 변경이 제대로 이뤄졌는지 살펴보는 것
  * 형상 상태 보고
    * 변경된 형상 항목을 관계된 사람들에게 알리는 것
* 형상관리 도구
  * CVS, SVN, Git, Perforce

---

### SW 개발 방법

* 비교

| 항목      | 정보공학                                                     | 객체지향                                                     | CBD                                                          |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 주요관점  | 데이터 중심                                                  | 객체 중심                                                    | 컴포넌트 중심                                                |
| SDLC 모델 | 폭포수 모델                                                  | 반복적 개발 모델                                             | 반복적 개발 모델                                             |
| 주요기술  | PC보급 확산                                                  | 인터넷 이용확산                                              | 비즈니스 기능 단위 컴포넌트                                  |
| 환경      | 전사규모의 정보시스템<br/>관계형DB                           | 다양한 SW요구증대<br/>객체지향 언어                          |                                                              |
| 주요기법  | 데이터모형(객체 관계도),정보전략계획, BRP, 분산설계          | 객체모형위험관리반복적/점진적개발분석/설계 패턴설계개선(Refactoring) | 컴포넌트 명세컴포넌트 추출컴포넌트 연동컴포넌트 설계         |
| 특징      | 안정된 개발방법론                                            | 실세계 개념 모형<br/>UML 사용 확산                           | 적기 개발개발비용 감소                                       |
| 장점      | 데이터 관점의 정규화 산출물이 단계별로 명확함, 대규모, 잘 알려진 프로젝트 적용 | 경험이 없는 프로젝트에 유용, 재사용성을 증대, 객체중심 개발, 의사소통 유리 | 컴포넌트 조립으로 개발, 생산성 향상, Time To Market 실현     |
| 단점      | 웹 환경에 적용 어려움, 분산환경, 컴포넌트 실행환경에 적용 어려움 | 대규모 프로젝트 적용 어려움, 성숙한 객체기술자 필요          | 조직에 따라 적용 가능한 컴포넌트 기술 수준이 다름, 업종별 특성을 지닌 컴포넌트 부족 |

---

### 요구사항

* 기능적 요구사항
  * 시스템에 주어지는 특정 입력에 대한 시스템이 산출하는 출력을 통해 정의
  * 시스템 기능, 입력, 출력
* 비기능적 요구사항
  * 제품요구사항
    * 사용성, 효율성, 이식성, 신뢰성
  * 조직요구사항
    * 배포, 구현, 표준
  * 외부요구사항
    * 상호운용성 : 구현할 소프트웨어가 다른 소프트웨어와 어떻게 연동할지 정의 

---

### CASE

> Computer Aided Software Engineering
> (컴퓨터 지원 소프트웨어 공학)

**CASE의 원천기술**

* 구조적 기법
  * 하향식, 기능식 분할 방법을 이용하여 시스템의 요구를 정의하는 모델링 기법
* 프로토타이핑
  * 시제품 형태의 소프트웨어를 단기간에 제작하여 사용자에게 제시함으로써 요구사항을 확정하고 개발을 진행하여 완성한 소프트웨어에 대한 사용자의 만족도를 높임으로써 비용을 절감할 수 있음
  * 프로토타입용 프로그래밍 언어, 스크린 레이아웃 제작도구, 보고서 설계를 위한 도구가 포함되어 있다
* 자동 프로그래밍 기술
* 정보 저장소 기술
  * 소프트웨어를 개발하는 동안에 모아진 시스템에 관련된 정보를 보관하여 관리하는 곳이다
  * 정보 저장소에 저장하는 정보는 소프트웨어 요구 분석 및 설계서 등이 포함된다
* 분산처리 기술

---

