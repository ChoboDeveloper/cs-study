# 데이터베이스

<br>

### ACID

**원자성(Atomicity)**

모든 작업이 반영되거나 모두 롤백

**일관성(Consistency)**

트랜잭션 작업이 시작되지 전에 데이터베이스 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 데이터베이스 상태를 유지해아한다.

예를들어 숫자컬럼에 문자열값을 저장이 안되도록 보장한다.

**고립성(Isolation)**

트랜잭션 작업 수행 중에는 다른 트랜잭션에 영향을 주어서도 안되고, 다른 트랜잭션들에 의해 간섭을 받아서도 안 된다.

**지속성(Durablility)**

한번 커밋된 트랜젝션의 내용은 영구적으로 적용되는 특성을 의미

성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

---

### 데이터 모델링

- 개념적 모델링

  > 개체와 개체들 간의 관계에서 ER다이어그램을 만드는 과정

- 논리적 모델링

  > ER다이어그램을 사용하여 관계 스키마 모델을 만드는 과정

  * 기본키/외래키 등의 속성 정의
  * 정규화
  * ERD -> RDB로의 Mapping

- 물리적 모델링

  > 관계 스키마 모델의 물리적 구조를 정의하고 구현하는 과정

  * 테이블/인덱스 설계

---

### SQL

> 비 절차적 언어

* 일반적으로 Interactive SQL을 의미한다.

### Embedded SQL

> 내장 SQL은 데이터베이스 내의 데이터를 정의하거나 접근하는 SQL문을 응용 프로그램 내에 내포하여 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어에 삽입한 SQL이다.

* 내장 SQL은 단 하나의 튜플만을 반환한다

**커서**

> 커서를 이용하여 업데이트 및 삭제도 가능하다.

* 내장 SQL문의 실행 결과로 반환된 복수 개의 튜플들을 접근할 수 있도록 해주는 개념
* 단일 레코드 검색문의 경우와 삽입, 갱신, 삭제의 경우에는 커서가 필요 없음
* 커서 명령어의 종류
  * DECLARE : 커서를 정의하는 등 커서에 관련된 선언을 하는 명령어
  * OPEN : 커서가 질의 결과의 첫 번째 튜플을 가리키도록 설정하는 명령어
  * FETCH : 질의 결과에 대한 튜플들 중 현재의 다음 튜플로 커서를 이동시키는 명령어
  * CLOSE : 질의 실행 결과에 대한 처리 종료 시 커서를 닫기 위해 사용하는 명령어
* 커서의 종류
  * 정적 커서
    * 정적 커서는 커서가 열릴 때 만족되는 데이터 모두를 Tempdb로 복사한다. 
    * 원본 테이블에 변경이 가해져도 커서 결과에는 영향이 없기 때문에 세 가지 커서 중에서 성능이 가장 좋다.
  * 동적 커서
    * 커서가 열릴 때 현재 위치의 키값만을 Tempdb로 복사한다. 
    * 원본 테이블에 삽입 및 변경이 가해지면 커서결과에도 영향을 미치게 된다.

### Static/Dynamic SQL

**static SQL**

- Static SQL이란, String형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문을 말한다.
  다른 말로 `Embedded SQL`이라고도 한다.

**dynamic SQL**

* Dynamic SQL이란, String형 변수에 담아서 기술하는 SQL문을 말한다.
* String 변수를 사용하므로 조건에 따라 SQL문을 동적으로 바꿀 수 있고, 또는 런타임 시에 사용자로부터 SQL문의 일부 또는 전부를 입력 받아서 실행할 수도 있다.

---

### 인덱스 선정 절차

1. 프로그램 개발에 이용된 모든 테이블에 대하여 접근 경로(Access Path) 조사

   프로그램에 사용된 모든 질의문의 테이블을 조사하고 해당 테이블의 접근 경로를 표를 통하여 도식화해서 표현하는 것이 좋다.

2. 인덱스 컬럼 설정

   접근 경로 표를 기준으로 어떤 컬럼이 자주 사용되는 지를 판단하고 해당 컬럼의 분포도를 조사해야 한다.

   분포도란 한 컬럼에 얼마나 다양한 값이 어떻게 분포되어 있는 지를 나타낸다.

* 포함해야 할 컬럼
  * Where 절에 자주 사용되는 컬럼
  * 테이블 조인을 위해 연결고리로 자주 사용되는 컬럼
  * 분포도가 좋거나 유일한 컬럼
  * select 문장의 MAX, MIN 기준이 되거나 정렬에 주로 사용되는 컬럼
* 포함하지 않아야 할 컬럼
  * 분포도가 좋지 않은 컬럼
  * 테이블의 Row 수가 적은 테이블의 컬럼
  * update가 빈번한 컬럼

---

### 클러스터링 테이블

> [[Oracle\] 오라클 인덱스 클러스터 테이블, Index Cluster Table (jungmina.com)](https://jungmina.com/821)

* 특정 동일 키 값을 가진 row들을 클러스터로 묶어서 같은 테이블에 저장하는 기법
* 클러스터 인덱스는 일반적인 인덱스와는 달리 데이터가 Distinct되어 저장된다.



**단일 테이블 클러스터**

* 클러스터에 하나의 테이블만 담음 

**다중 테이블 클러스터**

* 클러스터에 여러개의 테이블을 조인 상태로 담음

---

### 트랜잭션 관리

> [DBMS는 어떻게 트랜잭션을 관리할까? (naver.com)](https://d2.naver.com/helloworld/407507)

* DBMS는 Steal, No Force 정책을 사용
* STEAL: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
* NO FORCE: 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책
* NO FORCE에 의해 COMMIT한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있기 때문에 반드시 REDO 복구가 필요하게 된다.
* UNDO를 수행하고 나면 해당 UNDO 작업에 대한 보상 로그 레코드(CLR, Compensation Log Record)라고 하는 REDO 전용 로그를 쓰게 되는데, UNDO를 하고 난 이후에 다시 UNDO를 해서 복구가 잘못 이루어지지 않도록 하기 위함이다.

---

### 트랜잭션

### Locking 기법

**2단계 Locking**

> unlock 이후에 lock이 나올 수 없음

- 확장 단계(Growing Phase): 트랜잭션은 새로운 lock 연산만 할 수 있고, unlock 연산은 할 수 없는 단계
- 축소 단계(Shrinking Phase): 트랜잭션은 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계



### 회복기법

**즉시/지연갱신**

* 즉시 갱신
  * 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스에 기록
  * 커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO 필요

* 지연 갱신
  * 트랜잭션의 부분 완료 상태에선 변경 내용을 로그 파일에만 저장
  * 중간에 장애가 생기더라도 데이터베이스에 기록되지 않았으므로 UNDO가 필요 없음

**체크포인트**

* 검사점 이후 커밋은 Redo
* 즉시 갱신 시 검사점 이후 커밋이 없는 트랜잭션은 Undo

---

### TPC

> OLTP의 벤치마크 성능평가

* TPC-C
  * OLTP의 대표적인 벤치마크, 분당 트랜잭션 수
* TPC-H(개선하여 사용 중), TPC-D(폐기)
  * 의사 결정 지원 벤치 마크

---

### XML

> 데이터를 저장하고 전달할 목적으로 만들어졌으며, 저장되는 데이터의 구조를 기술하기 위한 언어

**DTD의 단점을 보완**

* 네임스페이스/DOM(문서객체모델) 미지원

* XML 문법이 아닌 별도의 문법으로 작성

* 제한된 타입만을 지원

* 재사용과 확장이 불가능

**XML 스키마(XSD)**

* 문서의 구조와 데이터를 기술
* 사용자 정의타입, 타입의 상속, 무결성 제약조건등을 정의
* xsd:schema
  * XML 스키마 선언
* xmlns
  *  XML 스키마의 네임스페이스 지정

**XPath**

* XML Path Language
* 문서의 특정 요소나 속성에 접근하기 위한 경로를 지정하는 언어

**XQuery**

* XML의 요소에 대한 대한 질의 제공

---

