# 데이터베이스

<br>

### ACID

**원자성(Atomicity)**

> 모든 작업이 반영되거나 모두 롤백

* 즉, 작업이 중간에 중단되는 일이 없어야 한다 (Recovery 관련)

**일관성(Consistency)**

> 트랜잭션 작업이 시작되지 전에 데이터베이스 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 데이터베이스 상태를 유지해야한다.

* 특정 도메인 값이나 not nulll 등의 제약조건을 지켜야 함 (Integrity 관련)

**고립성(Isolation)**

> 트랜잭션 작업 수행 중에는 다른 트랜잭션에 영향을 주어서도 안되고, 다른 트랜잭션들에 의해 간섭을 받아서도 안 된다.

**지속성(Durablility)**

> 한번 커밋된 트랜젝션의 내용은 영구적으로 적용되는 특성을 의미
>
> 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

* (Recovery 관련)

---

### Key

**기본키**

**후보키**

* 유일성 O / 최소성 O

**슈퍼키**

* 유일성 O / 최소성 X

**대체키**

**외래키**

---

### 무결성

**고유(Unique) 무결성** 

* 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성 값들이 서로 달라야 한다는 규정

**도메인(Domain) 무결성**

* 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정

**참조 무결성**

* 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되여야 한다는 규정

<br>

**기타**

* **엔티티 무결성**
  * 기본키 값은 널이 될 수 없다는 규정

* **키 무결성**
  * 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정

---

### 스키마

**내부 스키마**

* DB의 물리적 구조

**개념 스키마**

* DB의 논리적 구조
* 개체간의 관계와 제약조건 명시
* 데이터베이스 관리자(DBA)에 의해서 구성

**외부 스키마**

* 서브 스키마

* 여러 사용자의 뷰

---

### 뷰

* 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블

* 특징

  * 뷰는 ALTER문을 사용하여 변경할 수 없으므로 필요한 경우는 **삭제한 후 재생성**한다.

  * 독립적인 인덱스를 가질 수 없다.

  * 생성문

    ```sql
    CREATE OR REPLACE VIEW TEST_TABLE_VW
            AS SELECT A.ID
                            ,A.NAME
                            ,A.AMT
                            ,B.CHECK_YN
               FROM TEST_TABLE_ONE A,
                         TEST_TABLE_TWO B
                     WHERE A.IDX = B.IDX
    ```

  * 삭제문

    ```sql
    DROP VIEW 뷰이름 RESTRICT or CASCADE
    RESTRICT : 뷰를 다른곳에서 참조하고 있으면 삭제가 취소된다.
    CASCADE : 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제된다.
    ```
    
  * 뷰는 ORDER BY 를 단독으로 사용하지 못하고 TOP N, OFFSET 등과 함께 수행해야 한다.

---

### 시스템 카탈로그

**카탈로그 특징**

- 시스템 카탈로그는 데이터베이스 관리 시스템이 스스로 생성하고 유지
- 시스템 카탈로그 그 자체도 테이블로 구성되어 있어, **일반 사용자가 SQL SELECT문을 이용해 내용을 검색해 볼 수 있음**
- 시스템 카탈로그의 갱신
  - 사용자가 SQL의 DDL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변경을 주면 데이터베이스 관리 시스템이 자동으로 시스템 카탈로그를 변경
  - **사용자가 SQL의 INSERT, DELETE, UPDATE문으로 시스템 카탈로그를 직접 갱신하는 것은 허용되지 않음**
- 분산 시스템에서의 시스템 카탈로그는 보통의 릴레이션, 인덱스, 사용자 등의 정보를 포함할 뿐만 아니라 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보도 포함하고 있음

**카탈로그 정보**

* 릴레이션 관련 정보
* 인덱스 관련 정보
  - 인덱스의 이름과 구조
  - 인덱스가 정의된 속성 정보(예를 들면, B+-트리)
  - 키에 대한 정보
* 뷰 관련 정보
* 통계 정보
  - 릴레이션 카디널리티 : 각 릴레이션의 튜플 수
  - 릴레이션 크기 : 각 릴레이션에 대한 페이지 수
  - 인덱스 카디널리티 : 각 인덱스에 대한 상이한 키값 수
  - 인덱스 높이 : 각 트리 인덱스에 대한 레벨 수
  - 인덱스 범위 : 각 인덱스에 대한 최소 키값과 최대 키값
* 사용자 정보
  - 사용자의 계정 정보(패스워드 포함)
  - 사용자의 권한 정보
* 기타
  - 기본키, 외래키 등과 같은 제약 조건에 대한 명세
  - 성능 정보를 위한 저장 구조에 대한 명세
  - 보안 및 권한 정보 등

SYSTABLES : 기본 테이블 및 뷰 테이블의 정보를 저장하는 테이블

SYSCOLUMNS : 모든 테이블에 대한 정보를 열(속성) 중심으로 저장하는 테이블

SYSINDEXES : 인덱스 테이블에 대한 정보를 저장하는 테이블

SYSVIEW : 뷰에 대한 정보를 저장하는 테이블

SYSTABAUTH : 테이블에 설정된 권한 사항들을 저장하는 테이블

SYSCOLAUTH : 각 속성에 설정된 권한 사항들을 저장하는 테이블

SYSDEPEND : 기존 테이블과 뷰 사이의 종속 관계를 저장하는 테이블

SYSUSERS : 사용자의 권한 등급 정보를 저장하는 테이블



**※ 데이터 디렉토리(Data Directory)**

- 데이터 사전에 수록된 데이터를 실제로 접근하는데 필요한 정보를 가지고 있음
- DBMS에 의해서만 접근이 가능

---

### 데이터 모델링

- 개념적 모델링

  > 개체와 개체들 간의 관계에서 ER다이어그램을 만드는 과정

- 논리적 모델링

  > ER다이어그램을 사용하여 관계 스키마 모델을 만드는 과정

  * 기본키/외래키 등의 속성 정의
  * 정규화
  * ERD -> RDB로의 Mapping

- 물리적 모델링

  > 관계 스키마 모델의 물리적 구조를 정의하고 구현하는 과정

  * 테이블/인덱스 설계

---

### ERD

> [ E-R-Model :: 프라이데이 (tistory.com)](https://ganghee-lee.tistory.com/20)

![image](https://user-images.githubusercontent.com/75229881/152127195-b3a886fd-a315-474e-a7bd-07f3f5bb1d4d.png)

* 약한 개체/관계 타입
  * 기본키가 존재하지 않음

---

### Embedded SQL

> 내장 SQL은 데이터베이스 내의 데이터를 정의하거나 접근하는 SQL문을 응용 프로그램 내에 내포하여 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어에 삽입한 SQL이다.

* 내장 SQL은 단 하나의 튜플만을 반환한다

**커서**

> 커서를 이용하여 업데이트 및 삭제도 가능하다.

* 내장 SQL문의 실행 결과로 반환된 복수 개의 튜플들을 접근할 수 있도록 해주는 개념
* 단일 레코드 검색문의 경우와 삽입, 갱신, 삭제의 경우에는 커서가 필요 없음
* 커서 명령어의 종류
  * DECLARE : 커서를 정의하는 등 커서에 관련된 선언을 하는 명령어
  * OPEN : 커서가 질의 결과의 첫 번째 튜플을 가리키도록 설정하는 명령어
  * FETCH : 질의 결과에 대한 튜플들 중 현재의 다음 튜플로 커서를 이동시키는 명령어
  * CLOSE : 질의 실행 결과에 대한 처리 종료 시 커서를 닫기 위해 사용하는 명령어
* 커서의 종류
  * 정적 커서
    * 정적 커서는 커서가 열릴 때 만족되는 데이터 모두를 Tempdb로 복사한다. 
    * 원본 테이블에 변경이 가해져도 커서 결과에는 영향이 없기 때문에 세 가지 커서 중에서 성능이 가장 좋다.
  * 동적 커서
    * 커서가 열릴 때 현재 위치의 키값만을 Tempdb로 복사한다. 
    * 원본 테이블에 삽입 및 변경이 가해지면 커서결과에도 영향을 미치게 된다.

### Static/Dynamic SQL

**static SQL**

- Static SQL이란, String형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문을 말한다.
  다른 말로 `Embedded SQL`이라고도 한다.

**dynamic SQL**

* Dynamic SQL이란, String형 변수에 담아서 기술하는 SQL문을 말한다.
* String 변수를 사용하므로 조건에 따라 SQL문을 동적으로 바꿀 수 있고, 또는 런타임 시에 사용자로부터 SQL문의 일부 또는 전부를 입력 받아서 실행할 수도 있다.

---

### 클러스터링 테이블

> [[Oracle\] 오라클 인덱스 클러스터 테이블, Index Cluster Table (jungmina.com)](https://jungmina.com/821)

* 특정 동일 키 값을 가진 row들을 클러스터로 묶어서 같은 테이블에 저장하는 기법
* 클러스터 인덱스는 일반적인 인덱스와는 달리 데이터가 Distinct되어 저장된다.



**단일 테이블 클러스터**

* 클러스터에 하나의 테이블만 담음 

**다중 테이블 클러스터**

* 클러스터에 여러개의 테이블을 조인 상태로 담음

---

### 트랜잭션 관리

> [DBMS는 어떻게 트랜잭션을 관리할까? (naver.com)](https://d2.naver.com/helloworld/407507)

* DBMS는 Steal, No Force 정책을 사용
* STEAL: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
* NO FORCE: 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책
* NO FORCE에 의해 COMMIT한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있기 때문에 반드시 REDO 복구가 필요하게 된다.
* UNDO를 수행하고 나면 해당 UNDO 작업에 대한 보상 로그 레코드(CLR, Compensation Log Record)라고 하는 REDO 전용 로그를 쓰게 되는데, UNDO를 하고 난 이후에 다시 UNDO를 해서 복구가 잘못 이루어지지 않도록 하기 위함이다.

---

### TPC

> OLTP의 벤치마크 성능평가

* TPC-C
  * OLTP의 대표적인 벤치마크, 분당 트랜잭션 수
* TPC-H(개선하여 사용 중)
  * 의사 결정 지원 벤치 마크

---

### XML

> 데이터를 저장하고 전달할 목적으로 만들어졌으며, 저장되는 데이터의 구조를 기술하기 위한 언어

**DTD의 단점을 보완**

* 네임스페이스/DOM(문서객체모델) 미지원

* XML 문법이 아닌 별도의 전용문법으로 작성

* 제한된 타입만을 지원

* 재사용과 확장이 불가능

**XML 스키마(XSD)**

* 문서의 구조와 데이터를 기술
* 사용자 정의타입, 타입의 상속, 무결성 제약조건등을 정의
* xsd:schema
  * XML 스키마 선언
* xmlns
  *  XML 스키마의 네임스페이스 지정

**XPath**

* XML Path Language
* 문서의 특정 요소나 속성에 접근하기 위한 경로를 지정하는 언어

**XQuery**

* XML의 요소에 대한 대한 질의 제공

---

### 저장구조

**힙 파일**

* 순서가 없는 가장 간단한 파일
* 레코드들이 어떤 형태로든 정렬되지 않으며, 파일의 레코드들을 검색하려면 다음 레코드를 읽어야 함
* 추가할 때는 마지막 페이지를 읽어서 새로운 코드를 추가한 다음에 다시 기록한다.
* 검색의 경우 모든 페이지들을 읽어서 원하는 레코드인지 확인해야 하기 때문에 비효율적이다.

**순서 파일**

* 한 필드의 자료 값을 기준으로 레코드들을 정렬한 파일
* 순서필드 : 정렬의 기준이 되는 필드 ex) 순서 필드가 파일의 키라면 순서 키가 된다.
* 장점 : 레코드를 읽을 때, 부가적인 연산이 필요 없다, 검색처리가 신속하다.

**해시 파일**

* 탐색 키값을 이용하여 원하는 레코드를 신속하게 찾을 수 있도록 구성된 파일.
* 특징 : 키 값을 알면 다른 레코드 거치지 않고 직접 원하는 레코드를 찾을 수 있다.

---

### 분산 데이터베이스

**정의**

* **물리적으로 분산**되어 있는 데이터를 **네트워크를 통해** 논리적으로 동일한 **시스템에서 하나의 데이터베이스**처럼 이용하는 기술

**투명성**

* **위치 투명성(Location Transparency)** : 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.
* **중복 투명성(Replication Transparency)** : 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
* **병행 투명성(Concurrency Transparency)** : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
* **장애 투명성(Failure Transparency)** : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

**2단계 완료 프로토콜**

* 정의
  * 분산 데이터베이스의 트랜잭션 처리를 위해서 사용하는 고전적인 방법이다.
  * 2PC에서는 일반적으로 단일 노드 트랜잭션에서는 나타나지 않는 새로운 구성 요소인 **코디네이터(트랜잭션 관리자)**를 사용한다.
  * 지역 관리자는 **Cohort**

* 단계
  * 모든 참여자가 yes라고 응답하면, 코디네이터는 phase 2로 넘어가 commit 요청을 보내어 커밋이 수행되도록 함
  * 어느 하나라도 no를 응답하면, 코디네이터는 phase 2로 넘어가 모든 노드들에 abort 요청을 보냄
  * 성공시에 Cohorts에 commit 메시지를 전송하고 Resource Lock을 해제한다. 실패시에는 Cohorts에 rollback 메시지를 전송후 undo log를 이용해서 원래상태로 복구하고 Resource Lock이 있다면 해제한다.
  * 각 cohort는 트랜잭션 관리자에게 Acknowledgment를 전송한다. 성공시라면 작업을 완료하고 실패시라면 트랜잭션을 복구

---

### 암호화

**플러그인 방식**

* 암복화화 모듈이 **DB서버에 설치**되고, DB서버에서 플러그인으로 연결된 암복호화 모듈을 호출하는 방식
* 장점 
  * 어플리케이션 변경 최소화, **관리의 효율성**
* 단점
  * DB서버에 직접적인 부하가 걸려 **성능저하**

**API 방식**

* 암복호화 모듈이 API 라이브러리 형태로 **각 애플리케이션 서버에 설치**되어 응용프로그램에서 해당 암복호화 모듈을 호출하는 방식으로 애플리케이션 서버와 DB서버간의 통신에서 암호화된 데이터 전송 보장
* 장점
  * 암복호화 **속도 빠르고**, DB서버에 영향을 주지 않아 **DB성능저하가 적은 편**
* 단점
  * 응용 프로그램의 수정이 필요
  * 반면 각각의 애플리케이션 서버에서 암·복호화 처리를 수행하므로 **중앙화된 접근 통제가 어려워** 데이터베이스 내부에서 수행되는 연산 처리 과정에서 암호화한 데이터 처리가 불가능하다.

---

### 반정규화

* 데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 **I/O량이 많아서 성능이 저하**되는 경우
* 경로가 너무 멀어 **조인으로 인한 성능저하**가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.

**테이블 반정규화**

* 테이블 병합
* 테이블 분할
* 테이블 추가
  * 중복, 통계, 이력, 부분 테이블 등

**칼럼 반정규화**

* 중복칼럼 추가
  * 조인에 의한 성능저하 방지
* 파생칼럼 추가

**관계 반정규화**

* 중복관계 추가

---

### DB 구성요소

* **DDL 컴파일러** 또는 DDL처리기
  * DDL로 명세된 스키마 정의를 내부형태, 즉 메타 데이터(meta data)로 처리하여 시스템 카탈로그에 저장한다.
  * 이 카탈로그에는 파일의 이름과 크기, 데이터 아이템의 이름과 타입, 각 파일의 저장 세부 사항,
  * 스키마 사이의 사상 정보, 제약 조건 등 DBMS 모듈들이 필요로 하는 많은 종류의 정보들을 포함하고 있다.따라서 모든 DBMS 모듈들은 필요시에 이 카탈로그 정보를 접근해서 이용한다.

* **질의어 처리기**
  * 터미널을 통해 일반 사용자가 제출한 고급 질의문을 처리한다.
  * 이것은 질의문을 검사하고 파싱해서 컴파일한다.
  * 그리고 효율적인 데이터베이스 접근 코드를 생성한 뒤에, 이 코드 실행을 위해 런타임 데이터베이스 처리기에 보내진다.

* **DML 예비 컴파일러**
  * 호스트 프로그래밍 언어로 작성된 응용 프로그램속에 삽입되어 있는 **DML 명령문들을 추출**한다.
  * 이 명령문들은 데이터베이스 접근을 위한 목적 코드로 컴파일 되도록 DML 컴파일러에 보내진다.
  * 프로그램의 나머지 부분은 호스트 프로그래밍 언어의 컴파일러에 보내진다.

* **DML 컴파일러** 또는 DML처리기
  * DML 예비 컴파일러가 넘겨준 DML 명령어를 파싱하고 컴파일하여 효율적인 목적 코드를 생성한다.
  * 이 DML에 대한 목적코드는 호스트 프로그래밍 언어 컴파일러에 의해 처리된 나머지 응용 프로그램의 목적 코드와 연결되어 런타임 데이터베이스 처리기에 의해 실행된다.

* **런타임 데이터베이스 처리기**
  * 실행 시간에 데이터베이스 접근을 관리한다.
  * 이것은 검색이나 갱신과 같은 데이터베이스 연산을 저장 데이터 관리자를 통해 디스크에 저장된 데이터베이스에 실행시킨다.

* **트랜잭션 관리자**
  * 데이터베이스를 접근하는 과정에서 무결성 제약조건이 만족하는지, 데이터를 접근할 권한을 사용자가 가지고 있는지 **권한 검사**를 한다.
  * 또한 여러 사용자의 요구를 동시에 처리할 수 있도록 트랜잭션의 병행 제어나 장애발생시 회복 작업을 수행한다.

* **저장데이터 관리자**
  * 디스크에 저장되어 있는 사용자 데이터베이스나 카탈로그 접근을 책임진다.
  * 디스크에 저장되어 있는 저장 레코드의 접근 요청은 파일 관리자가 먼저 어떤 파일의 어떤 페이지인가를 결정하고, 실제로 디스크와 메인 메모리 버퍼 사이의 데이터 전송을 책임지고 있는 디스크 관리자로 하여금 수행케 한다.

---



