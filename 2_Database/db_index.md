# Index

<Br>

### 특징

**장점**

- **키 값을 기초로** 하여 테이블에서 **검색과 정렬 속도를 향상**시킨다.
- 질의나 보고서에서 그룹화 **작업의 속도를 향상**시킨다.
- 인덱스를 사용하면 **테이블 행의 고유성을 강화**시킬 수 있다.

**단점**

- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- Index 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어진다.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.
- Index를 생성하는데 시간이 많이 소요될 수 있다.
- Index가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다.

**Index를 남발한다면?**

```
* 데이터베이스 서버에 성능문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성이다. 

* 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래한다.

* 조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서 Insert, Delete, Update시에 부하가 발생해 전체적인 데이터베이스 성능을 저하한다.

* 그렇기에 인덱스를 생성하는것 보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 나가야한다. 따라서, 성능문제를 해결하기 위해서 인덱스 생성은 마지막 수단으로 강구해야 할 문제이다.
```

---

### 쿼리

```mysql
CREATE INDEX [인덱스명] ON [테이블명](컬럼1, 컬럼2, 컬럼3.......);
EX> CREATE INDEX EX_INDEX ON CUSTOMERS(NAME,ADDRESS);

// UNIQUE 키워드를 붙이면 컬럼값에 중복값을 허용하지 않는다는 뜻
EX> CREATE[UNIQUE] INDEX EX_INDEX ON CUSTOMERS(NAME,ADDRESS); 

ALTER TABLE  테이블명 ADD INDEX(필드명(크기));

CREATE TABLE 테이블 명 ( 필드명 데이터타입(데이터크기), INDEX(필드명(크기)) ENGINE MyISAM; 
```

---

### 인덱스 선정

| 포함해야 할 컬럼                                 | 포함하지 않는 컬럼            |
| ------------------------------------------------ | ----------------------------- |
| Where 절에 자주 사용되는 컬럼                    |                               |
| 테이블 조인을 위해 연결고리로 자주 사용되는 컬럼 |                               |
| 통계나 정렬에 주로 사용되는 컬럼                 |                               |
| 분포도가 양호하거나 유일한 컬럼                  | 분포도가 좋지 않은(높은) 컬럼 |
| UPDATE가 자주 발생하지 않는 컬럼                 | update가 빈번한 컬럼          |
| Row 수가 많은 테이블                             | Row 수가 적은 테이블의 컬럼   |

* 분포도(%)
  * (데이터별 평균 Rows / 테이블 총 Rows) \* 100
  * **분포도가 낮을수록 좋다**
  * 분포도가 10~15% 정도이면 인덱스 컬럼 후보로 사용 한다
  * 만약 15% 이상이면 인덱스를 이용하여도 인덱스에 의한 랜덤 I/O 발생으로 성능을 보장할수 없다.

---

### 알고리즘

**B+ Tree**

* Index에 **일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘**이다.
* B+ Tree 인덱스는 컬럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다.

**Hash**

* 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
* 하지만 **값을 변형해서 인덱싱**하므로, **특정 문자로 시작하는 값으로 검색**을 하는 등 **전방 일치와 같이 값의 일부만으로 검색**하고자 할 때는 **해시 인덱스를 사용할 수 없다.** 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

 **Hash Table말고 B-Tree를 사용하는 이유**

```
데이터 접근에 시간 복잡도가 O(1)인 Hash Table말고 B-Tree를 사용하는 이유는 SELECT 절의 조건에 부등호 연산(>, <)이 포함될 경우 문제가 발생한다.
HashTable은 동등 연산(=)에 특화되어있어 데이터베이스의 자료구조에 적합하지 않다.
```

---

### 인덱스 종류

**Clustered 인덱스**

* Clustered 인덱스는 물리적 정렬로 DB에 데이터를 입력 시 Clustered 인덱스를 기준으로 입력이 된다.
* 따라서 **한 테이블에 오직 하나만 존재** 할 수 있으며 Table을열었을 때 Order By를 사용하지 않아도 데이터가 **Clustered 인덱스에 따라 정렬이 되어 있는 것을 확인** 할 수있다.
* **물리적으로 정렬**이 되어 있는 만큼 **가장 빠른 처리**를 한다.

**NonClustered 인덱스**

* NonClustered 인덱스는 clustered 인덱스와는 달리 중복된 값을 가지면 **한 테이블에 여러 개를 생성 할 수 있다.**
* 자동 정렬되지 않고, Index를 생성할 때는 Clustered가 되어있을 때, Index Scan이 유리하다.

---

### 비트맵 인덱스

- 각 튜플 당 하나의 속성에대해 튜플 수 만큼의 비트를 가진다.
- 해당 속성에 속하면 1, 아니면 0로 표시한다.

---

