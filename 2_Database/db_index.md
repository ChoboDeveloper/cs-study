# Index

<Br>

### 특징

**장점**

- **키 값을 기초로** 하여 테이블에서 **검색과 정렬 속도를 향상**시킨다.
- 질의나 보고서에서 그룹화 **작업의 속도를 향상**시킨다.
- 인덱스를 사용하면 **테이블 행의 고유성을 강화**시킬 수 있다.

**단점**

- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- Index 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어진다.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.
- Index를 생성하는데 시간이 많이 소요될 수 있다.
- Index가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다.

**Index를 남발한다면?**

```
* 데이터베이스 서버에 성능문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성이다. 

* 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게는 만들 수 있지만
전체적인 데이터베이스의 성능 부하를 초래한다.

* 조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서 Insert, Delete, Update시에 
부하가 발생해 전체적인 데이터베이스 성능을 저하한다.

* 그렇기에 인덱스를 생성하는것 보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 나가야한다. 
따라서, 성능문제를 해결하기 위해서 인덱스 생성은 마지막 수단으로 강구해야 할 문제이다.
```

---

### 쿼리

```mysql
CREATE INDEX [인덱스명] ON [테이블명](컬럼1, 컬럼2, 컬럼3.......);
EX> CREATE INDEX EX_INDEX ON CUSTOMERS(NAME,ADDRESS);

// UNIQUE 키워드를 붙이면 컬럼값에 중복값을 허용하지 않는다는 뜻
EX> CREATE[UNIQUE] INDEX EX_INDEX ON CUSTOMERS(NAME,ADDRESS); 

ALTER TABLE  테이블명 ADD INDEX(필드명(크기));

CREATE TABLE 테이블 명 ( 필드명 데이터타입(데이터크기), INDEX(필드명(크기)) ENGINE MyISAM; 
```

---

### 인덱스 선정

| 포함해야 할 컬럼                                 | 포함하지 않는 컬럼            |
| ------------------------------------------------ | ----------------------------- |
| Where 절에 자주 사용되는 컬럼                    |                               |
| 테이블 조인을 위해 연결고리로 자주 사용되는 컬럼 |                               |
| 통계나 정렬에 주로 사용되는 컬럼                 |                               |
| 분포도가 양호하거나 유일한 컬럼                  | 분포도가 좋지 않은(높은) 컬럼 |
| UPDATE가 자주 발생하지 않는 컬럼                 | update가 빈번한 컬럼          |
| Row 수가 많은 테이블                             | Row 수가 적은 테이블의 컬럼   |

* 분포도(%)
  * (데이터별 평균 Rows / 테이블 총 Rows) \* 100
  * **분포도가 낮을수록 좋다**
  * 분포도가 10~15% 정도이면 인덱스 컬럼 후보로 사용 한다
  * 만약 15% 이상이면 인덱스를 이용하여도 인덱스에 의한 랜덤 I/O 발생으로 성능을 보장할수 없다.

---

### 알고리즘

**B-Tree**

* 특징
  * root, leaf를 제외한 노드는 **최대 M개 부터 최소 ⌈M/2⌉까지의 자식**을 가질 수 있다.
  *  leaf node 는 **최소 ⌈M/2⌉-1개의 key** 를 가지고 있어야 한다.

**B+ Tree**

* Index에 **일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘**이다.
* B+ Tree 인덱스는 컬럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다.
* 루트 노드를 제외하고 절반 이상의 사용률을 보장한다.

**Hash**

* 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
* 하지만 **값을 변형해서 인덱싱**하므로, **특정 문자로 시작하는 값으로 검색**을 하는 등 **전방 일치와 같이 값의 일부만으로 검색**하고자 할 때는 **해시 인덱스를 사용할 수 없다.** 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

 **Hash Table말고 B-Tree를 사용하는 이유**

```
데이터 접근에 시간 복잡도가 O(1)인 Hash Table말고 B-Tree를 사용하는 이유는 
SELECT 절의 조건에 부등호 연산(>, <)이 포함될 경우 문제가 발생한다.
HashTable은 동등 연산(=)에 특화되어있어 데이터베이스의 자료구조에 적합하지 않다.
```

---

### 인덱스 종류

**Clustered 인덱스**

* Clustered 인덱스는 물리적 정렬로 DB에 데이터를 입력 시 Clustered 인덱스를 기준으로 입력이 된다.
* 따라서 **한 테이블에 오직 하나만 존재** 할 수 있으며 Table을열었을 때 Order By를 사용하지 않아도 데이터가 **Clustered 인덱스에 따라 정렬이 되어 있는 것을 확인** 할 수있다.
* **물리적으로 정렬**이 되어 있는 만큼 **가장 빠른 처리**를 한다.

**NonClustered 인덱스**

* NonClustered 인덱스는 clustered 인덱스와는 달리 중복된 값을 가지면 **한 테이블에 여러 개를 생성 할 수 있다.**
* 자동 정렬되지 않고, Index를 생성할 때는 Clustered가 되어있을 때, Index Scan이 유리하다.

---

### 비트맵 인덱스

- 각 튜플 당 하나의 속성에대해 튜플 수 만큼의 비트를 가진다.
- 해당 속성에 속하면 1, 아니면 0로 표시한다.

---

### 파일 접근 기법

**순차파일**

* 생성되는 순서에 따라 레코드를 순차적으로 저장, 저장 매체의 효율이 가장 높음
* 프로그래밍이 쉬우며, 대화식 처리보다 일괄 처리에 적합한 구조
* 여러 개의 기록 매체에 기록이 가능
* 필요한 레코드를 삽입, 삭제하는 경우 파일을 재구성해야 하므로 파일 전체를 복사해야 함

**직접파일**

* 특정 레코드에 접근하기 위해서 디스크의 물리적 주소로 변환할 수 있는 함수
* 해싱을 이용한 파일 구조
*  직접 접근 방식 (**DAM** : Directed Access Method)
  - 데이터의 입/출력이 빈번히 발생하는 곳에 응용
  - 해싱 함수를 이용하여 레코드의 저장 위치를 결정
  - 다른 레코드를 참조하지 않고 어떤 레코드를 접근할 수 있음

**인덱스 순차 파일(ISAM)**

* 키 값에 따라 순차적으로 정렬된 데이터를 저장하는 데이터 지역(Data Area)과 이 지역에 대한 포인터를 가진 색인 지역(Index Area)으로 구성된 파일
* 구성
  - **데이터 구역**은 데이터 레코드를 저장
  - **인덱스 구역**은 데이터 구역에 대한 인덱스를 저장
    - 트랙 인덱스
    - 마스터 인덱스
    - 실린더 인덱스
  - **오버플로우 구역**은 기본 데이터 구역에서 오버플로우 된 레코드를 저장
* 데이터 파일은 기본 구역과 오버플로우 구역으로 구성
* 실제 데이터 처리 외에 인덱스를 처리하는 추가적인 시간이 소모되므로 파일 처리속도 느림
* 순차 처리와 직접(랜덤) 처리가 모두 가능하지만 기억 장소 낭비 초래
* 레코드를 추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없음

**VSAM 파일**

* VASM(Virtual Storage Access Method) 파일은 동적 인덱스 방법을 이용한 색인 순차 파일이다.
* 구성
  * **제어 구간(Control Interval)** : 데이터 레코드가 저장되는 부분
  * **제어 구역(Control Area)** : 몇 개의 제어 구간을 모아 놓은 것
  * **순차 세트(Sequence Set)** : 제어 구역에 대한 인덱스를 저장한 것
  * **인덱스 세트(Index Set)** : 순차 세트의 상위 인덱스

* VSAM 파일은 기본구역과 오버플로 구역을 구분하지 않는다
* 레코드를 삭제하면 그 공간을 재사용할 수 있다
* 제어 구간에 가변 길이 레코드를 쉽게 수용할 수 있다

---

