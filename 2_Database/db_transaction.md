# 트랜잭션

<br>

### 트랜잭션 격리 수준

**Read Uncommited** : Dirty Read, Non-repeatable Read, Phantom Read 발생

* Commit 되지 않은 데이터를 읽을 수 있다.

**Read Committed** :  Dirty Read 방지 / Non-repeatable Read, Phantom Read 발생

* Commit 된 데이터만 읽을 수 있다.

**Repeatable Read** : Dirty Read, Non-repeatable Read 방지 / Phantom Read 발생

**Serializable** : Dirty Read, Non-repeatable Read, Phantom Read 방지

> Dirty Read : T1이 트랜잭션 도중 T2가 값을 읽었으나 Rollback이 일어나면 발생 (Read date Disappeared)
>
> Non-repeatable Read : T1이 데이터를 읽고 T2가 데이터를 쓰고(Update) T1이 다시 한번 데이터를 읽을 때 생기는 문제 (Read Data Changed) - 읽은 값이 달라졌다?
>
> Phantom Read : T1이 데이터를 읽고 T2가 데이터를 쓰고(Insert) T1이 다시 한번 데이터를 읽을 때 생기는 문제, (Non-Read Data Inserted) - 모르는 값이 생겼다?

---

### 직렬성

**충돌 직렬성**

> 서로 다른 트랜잭션에서 동일한 자원에 대해 연속적으로 읽기/읽기를 제외한 쓰기가 하나라도 발생하면 충돌

* 각 트랜잭션에서 R1(x), W2(x)와 같이 연속적으로 동일 데이터에 접근했을 때 R,R을 제외하고 선행 그래프로 표현할 수 있다. 여기서 Cycle이 형성된 경우 충돌이 발생한 것이며, 충돌이 발생하지 않은 경우 충돌 직렬성을 가진다고 말한다.

**뷰 직렬성**

* 모든 충돌 직렬 스케줄은 뷰 직렬

* 충돌 직렬이 아니고 blind write인 경우(읽지 않고 쓰기) 뷰 직렬
* 모든 트랙잭션이 같은 값을 Read하면 뷰 직렬

---

### Locking 기법

**2단계 Locking**

> unlock 이후에 lock이 나올 수 없음

- 확장 단계(Growing Phase): 트랜잭션은 새로운 lock 연산만 할 수 있고, unlock 연산은 할 수 없는 단계
- 축소 단계(Shrinking Phase): 트랜잭션은 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계

---

### 회복기법

**즉시/지연갱신**

* 즉시 갱신
  * 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스에 기록
  * 커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO 필요

* 지연 갱신
  * 트랜잭션의 부분 완료 상태에선 변경 내용을 로그 파일에만 저장
  * 중간에 장애가 생기더라도 데이터베이스에 기록되지 않았으므로 UNDO가 필요 없음

**체크포인트**

* 검사점 이후 커밋은 Redo
* 즉시 갱신 시 검사점 이후 커밋이 없는 트랜잭션은 Undo

---

### 복구성

**연쇄 복구 스케줄**

* 하나의 트랜잭션이 취소됨으로써 쓴 값을 읽어간 일련의 **트랜잭션들이 따라서 취소**되는 현상
* 예를들어, S1에서 T1:W(A), T2:R(A),W(A) T3:R(A) 를 연속적으로 실행한경우 T1를 Rollback할 경우 T2, T3 연속으로 Rollback 되어야함. 

**비연쇄 스케줄**

* Ti에 의하여 쓰여진 하나의 자료 항목을 Tj가 읽는 한 쌍의 트랜잭션 Ti와 Tj 에서 Tj의 읽기 연산에 앞서 Ti의 완료 연산이 실행되는 스케줄
* 위의 경우와 달리 T1을 Commit한 경우, T1만 철회함으로 이를 해결 가능
* **연쇄 복구 스케줄이 아니라면 비연쇄 스케줄**

**뷰 동치 스케줄**

* S1, S2는 같은 트랜잭션들을 포함해야함
* **각 트랜잭션은 같은 값을 Read 해야함**
* 마지막 Write연산이 같아야함

---

### 교착상태

* TimeStamp를 활용하여 데드록방지
  * Wait-Die 방식
    * 다른 트랜잭션이 락을 점유중이라면 기다리거나(Wait) 포기한다(Die).
  * Wound-Wait 방식
    * 다른 트랜잭션이 락을 점유중이라면 빼앗거나(Wound) 대기한다(Wait).
* TimeStamp를 활용하지 않는 방식
  * No Waiting
    * 기다리지 않고 철회됨
  * Cautious Waiting
    * 다른 트랜잭션이 블로킹된 상태가 아니라면 블로킹이 되어 대기하고 아닌 경우 철회됨

---

### 병행제어

* 로킹
* 타임스탬프
* 낙관적 병행제어

  * 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
  * 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경됐는지를 반드시 검사
  * 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영

|        과정         |                    동작                     |
| :-----------------: | :-----------------------------------------: |
|    1. Read Phase    |           검증 없이 트랜잭션 수행           |
| 2. Validation Phase |          종료 시 동시성 검증 수행           |
| 3. Execution Phase  | 문제 없을 시 기록, 동시성 문제 발견 시 철회 |

* 비관적 병행제어

  * 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
  * 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지
  * SELECT 시점에 Lock을 거는 비관적 동시성 제어는 시스템의 동시성을 심각하게 떨어뜨릴 수 있어서 wait 또는 nowait 옵션과 함께 사용해야 함

* 다중버전 병행제어(**MVCC**)

  > 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나이다. 
  >
  > MVCC 모델에서 데이터에 접근하는 사용자는 **접근한 시점에서 데이터베이스의 Snapshot**을 읽는다. 
  >
  > 이 snapshot 데이터에 대한 변경이 완료될 때 (트랜잭션이 commit 될 때) 까지 만들어진 변경사항은 다른 데이터베이스 사용자가 볼 수 없다.
  >
  > 이제 사용자가 데이터를 업데이트하면 이전의 데이터를 덮어 씌우는게 아니라 새로운 버전의 데이터를 UNDO 영역에 생성한다. 대신 이전 버전의 데이터와 비교해서 변경된 내용을 기록한다. 
  >
  > 이렇게 해서 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽게 된다.

  * 일반적인 RDBMS보다 매우 빠르게 작동
  * 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요
  * 데이터 버전이 충돌하면 애플리케이션 영역에서 이러한 문제를 해결해야 함

----



