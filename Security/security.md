# 정보보안



### 트로이목마

* **트로이 목마**(Trojan horse)는 악성 루틴이 숨어 있는 프로그램으로, 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행한다. 

1. 넷버스 (Netbus) - 12345번 포트 사용. 가장 사용하기 쉽고 퍼지기 쉬운 트로이 중의 하나.
2. 백오리피스 (Back Orifice) - 31337번 포트 사용. 가장 유명하여 제거 툴이 가장 많은 트로이.
3. 스쿨버스 (Schoolbus) - 54321번 포트 사용.
4. Executor - 80번 포트 사용. 감염된 컴퓨터의 시스템 파일을 삭제/시스템을 파괴하는 트로이 중의 하나.
5. Silencer - 1001번 포트 사용. 제거 툴은 나와 있지 않음.
6. Striker - 2565번 포트 사용. 감염된 컴퓨터를 무조건 고물로 만들어 버림. 이는 시스템 드라이브 등 하드디스크를 모두 파괴하여 아예 부팅이 안 되게 하는 트로이이기 때문

---

### 전자우편 보안

* 기밀성, 인증, 무결성, 부인방지를 제공한다.

* 대표적으로 PGP, PEM, S/MIME 등이 있다.

* PGP(Pretty Good Privacy)

  * 구현이 용이해 가장 널리 사용되고 있고 다양한 플랫폼에서 사용가능하다.

  * | 기능                  | 알고리즘                         | 설명                                                         |
    | :-------------------- | :------------------------------- | :----------------------------------------------------------- |
    | 기밀성(메시지 암호화) | Triple-DES,IDEA, CAST, RSA       | 송신자가 생성한 일회용 세션키로 알고리즘을 이용해 메시지 암호화.<br>수신자의 공개키로 RSA를 이용해서 세션키를 암호화하고 메시지에 첨부. |
    | 인증(전자 서명)       | RSA, DSS, SHA-1, MD5, RIPEMD-160 | 해시 알고리즘을 이용해서 메시지 다이제스트를 생성.<br>메시지 다이제스트는 송신자의 개인키로 DSS나 RSA를 이용해서 암호화한 후 메시지에 첨부한다. |
    | 압축                  | ZIP                              | ZIP으로 메시지를 압축한다.                                   |
    | 호환성                | Radix-64 변환                    | Radix-64 변환을 이용해 ASCII 부호로 변환한다.                |

* S/MIME(Secure Multipurpose Internet Mail Extensions)

  *  S/MIME은 기존 전자 우편 보안 시스템의 문제점인 PEM 구현의 복잡성과, PGP의 낮은 보안성과 기존 시스템과의 통합이 용이하지 않다는 점을 보안하기 위해 개발된 우편 보안 시스템이다.

---

### 악성코드

* 스파이웨어

사용자의 PC에서 사전 동의 없이 설치되어 컴퓨터의 정보와 개인 정보를 수집하는 악성코드의 종류이다. 신용카드와 같은 금융정보 및 주민등록번호와 같은 신상정보, 사이트 아이디나 비밀번호 등의 각종 정보를 수집하여 원격지의 특정 서버에 주기적으로 보내는 형태를 말한다.

* 백도어

감염된 사용자 PC에 특정 포트를 열어두어 정상적인 인증 과정 없이 원격 접속을 통해 직접 조작하는 형태로, 사용자 몰래 특정 파일을 삭제하거나 파일이나 정보를 빼가는 등의 행위를 한다.

* 키로거

컴퓨터가 입력받는 정보를 기록하는 것으로 그 중에서도 주로 키보드를 통한 메시지를 중간에 가로채서 기록하는 형태를 말한다. 

* 드롭퍼

일종의 악성 프로그램의 설치 프로그램의 형태로, 실행 시 내부에 포함되어 있던 바이러스나 웜, 또는 트로이 목마 등의 악의적인 프로그램이 설치되는 형태의 악성코드를 말한다.

* 다운로더

프로그램에서 지정한 웹 사이트에 접속하여 추가 악성코드를 다운로드하여 실행시키는 악성코드. 다운로더는 드롭퍼와 같이 백신 프로그램을 우회하는 목적으로 사용된다.

* 루트킷

악의적인 행동을 하는 프로그램을 숨기기 위한 목적으로 시작된 악성코드로, 현재는 프로세스나 파일 등의 흔적을 사용자가 볼 수 없도록 하는 프로그램에 대한 이름으로 사용된다.

* 부트킷

 PC의 부팅영역인 MBR(Master Boot Record)를 조작하는 프로그램을 칭하는 이름으로, 크게 파괴형 부트킷과 은신형 부트킷으로 나뉜다.

* Bot

인간의 행동을 흉내 내는 프로그램으로 DDoS 공격을 수행한다.

---

### 바이러스

* 원시형 바이러스

프로그램 구조가 단순하고 분석이 상대적으로 쉽다. 

돌 바이러스, 예루살렘 바이러스 등 기존의 도스용 바이러스 대부분이 포함된다.

* 암호화 바이러스

프로그램의 일부 또는 대부분을 암호화시켜 저장한다. 

폭포 바이러스, 느림보 바이러스 등이 있다.

* 은폐형 바이러스

기억장소에 존재하면서 감염된 파일의 길이가 증가되지 않은 것처럼 보이게 하며, 백신 프로그램이 감염된 부분을 읽을 때 감염되기 전의 내용을 보여준다.

브레인 바이러스, 조쉬 바이러스, 방랑자.1347 바이러스 등이 있다.

* 갑옷형 바이러스

백신 프로그램으로부터 숨기보다는 여러 단계의 암호화와 다양한 기법을 통해 바이러스 분석을 어렵게 하고 백신 프로그램 개발을 지연시켰다.

* 매크로 바이러스

운영체제와 관계없이 동작하는 응용 프로그램 내부에서 동작한다. 매크로 언어가 포함된 MS사 오피스 제품군과 비지오, 오토캐드 등 VBS를 지원하는 다양한 프로그램에서 활동한다. 

워드 컨셉, 엑셀-라룩스, 멜리사 바이러스 등이 있다.

> 매크로
>
>  C/C++ 등, 매크로를 지원하는 언어에서 약식 문법을 정의하면, 컴파일러가 컴파일을 하기 전에 약식 문법으로 정의된 코드를 원래 코드로 변환을 한 후 컴파일한다.

* 스텔스 바이러스

어떤 백신 프로그램으로도 예방 또는 감염경로를 확인할 수 없는 최악의 컴퓨터 바이러스

* 다변형 바이러스

감염시킬 때마다 바이트 패턴을 변형하는 바이러스, 특징을 이용한 탐지가 불가능

* 메타모픽 바이러스

다변형 바이러스와 마찬가지로 감염시킬 때마다 변형하고 추가로 활동하는 방법도 변형

---

### 디지털 포렌식

1. 정당성의 원칙

획득한 증거 자료가 적법한 절차를 준수해야 하며, 위법한 방법으로 수집된 증거는 법적 효력을 상실한다.

2. 무결성의 원칙

수집 증거가 위/변조되지 않았음을 증명할 수 있어야 한다.

3. 재현의 원칙

같은 조건과 상황에서 항상 같은 결과가 나오도록 재현할 수 있어야 하고, 수행할 때마다 다른 결과가 나온다면 증거로 제시할 수 없다.

4. 신속성의 원칙

휘발성 증거의 수집 여부는 신속한 조치에 의해 결정되므로 모든 과정은 지체없이 진행되어야한다.

 5. 관리 연속성의 원칙

증거물 획득 -> 이송 -> 분석 -> 보관 -> 법정 제출의 각 단계에서 담당자 및 책임자를 명확히 해야한다.

---

### SQL 인젝션

SQL 인젝션은 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법을 말한다.

* 대응기법
  * 입력 값에 대한 적극적인 유효성 검증
  * 저장 프로시저 사용
    * 저장 프로시저는 사용하자고 하는 Query에 미리 형식을 지정하는 것을 말힌다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성을 크게 향상시킴
  * 인터프리터에 대한 특수 문자 필터링 처리
  * 보안 프로토콜 및 암호 키 사용 여부 확인

---

### 리눅스 명령어

* chown 
  * chown 명령어는 파일 및 디렉토리의 소유권을 바꾸는 명령어
  * 하위 사용자는 최고 권한 사용자인 root에게 권한부여를 할 수 없다. (소유자 변경도 마찬가지)

* chmod

  * 파일, 디렉토리의 권한을 변경하는 명령어

  * > **u 사용자, g 그룹, o 다른사용자, a 전부**
    >
    > chmod **g+w** test.c
    >
    > 그룹에 쓰기 권한을 준다
    >
    > chmod **o-r** test.c
    >
    > 다른 사용자에게 읽기 권한을 빼앗는다

---

### CC

 국가마다 서로 다른 정보보호시스템 평가기준을 연동하고 평가결과를 상호 인증하기 위해 제정된 정보보안 평가기준

- ISO/IEC 15408 국제 표준

* CC인증의 평가보증등급

| 등급 | 주요내용       | 산출물                       |
| ----- | ------------------ | ---------------------------- |
| EAL1  | 기능 시험          | 기능 명세서, 설명서          |
| EAL 2 | 구조 시험          | 기본설계서, 기능시험서       |
| EAL 3 | 체계적 시험        | 생명주기, 개발보안, 오용분석 |
| EAL 4 | 설계 시험/검토     | 상세설계, 보안정책, 상세시험 |
| EAL 5 | 준정형화 설계/시험 | 개발문서, 보안기능 전체코드  |
| EAL 6 | 준정형화 설계 검증 | 전체 소스 코드               |
| EAL 7 | 정형화 설계 검증   | 개발 문서 정형화 기술        |

___

### SSL 인증서

* Root 인증서는 세상 사람들이 모두 신뢰하기로 약속한 기관, 예를 들어 위에서 언급한 Geotrust 등의 기관에서 발행한 인증서가 된다. 이러한 인증서는 일반적으로 웹 브라우저 등에 미리 내장되어 있으며, 해당 인증서에 대응하는 공개 키 또한 인증서 내부에 포함되어 있다.
* Google CA와 같은 CA회사의 인증서는 이러한 Root 인증서에 요청하여 root 인증서의 개인키를 통해 암호화되어 신뢰성을 보장받는다. 따라서, **Google CA의 인증서의 내용물에 대한 해시 값을, Geotrust가 Geotrust의 비밀 키로 암호화 해준것일테니, Google CA 또한 신뢰할 수 있다.**
* 여기서 해시값은 인증서의 주요정보를 모아 SHA256등의 해쉬 알고리즘을 이용하여 해쉬를 수행하고, 이렇게 해서 나온 해시값을 인증서의 **Finger Print(지문)**이라고 한다. 이렇게 나온 해시값(Finger Print)을 발급자(issuer)(CA)의 개인키로 암호화한 값이 **서명값(Digital Signing)**이다.
* CA의 공개키로 서명값을 복호화했을 때 이러한 해시값의 비교를 통해 해당 인증서의 무결성을 검증할 수 있다.
* [참고자료]([154. [Security\] SSL과 인증서 구조 이해하기 : CA (Certificate Authority) 를 중심으로 : 네이버 블로그 (naver.com)](https://m.blog.naver.com/alice_k106/221468341565))

---

### PKI

* 구성 : 인증기관(CA), 등록대행기관(RA), Certificate Repository, 사용자
* Certificate Repository는 인증서 및 인증서 폐기 목록(CRL)을 보관한다.
* 사용자가 인증서를 RA에 신청하면 RA에서 신청자의 신분을 검증하여 해당 사용자의 인증서 발급을 CA에 요청하고, CA에서는 암호하 key 쌍(Public Key, Private Key)을 생성하여 개인키인 Private Key는 사용자에, Public Key를 포함한 인증서는 인증서 저장소(Certificate Repository)에 저장함



---

### 블록암호 모드

* ECB모드
  * 평문을 동일한 블럭으로 나눠서 같은 방식으로 암호화
  * 패턴이 나타나기 때문에 안정성이 떨어진다.
* CBC모드
  * IV를 사용하고 앞의 블럭과 XOR 한 뒤 암호화
  * 오류전이 발생
* CFB모드
  * IV를 사용하고 앞의 블럭을 암호화 한 뒤 XOR
  * 오류전이 발생
* OFB모드
  * IV에 대한 연속적으로 암호화, 이를 평문블럭과 XOR
* CTR 모드
  * 카운터를 암호화, 이를 평문블럭과 XOR

---

### 의사 난수

* 무작위성 :  비트 수의 출현 빈도가 동일해야한다. 즉, 특정 분포를 보여서는 안된다.
* 비예측성 : 수열의 잇따른 다음 수의 순서에 대해 예측이 불가능해야한다.
* 약한 의사 난수는 무작위성만을 가지고, 강한 의사 난수는 비 예측성을 포함한다. 이러한 비예측성을 생성하기 위해 비결정적 알고리즘이 사용될 수 있다.
* True Random Number은 재현불가능성을 포함한다. 컴퓨터는 유한 오토마타이고 결국 시드값을 통해 난수를 생성하기 때문에 True Random Number를 구현하기 어렵다.

---

### 커버로스

구성요소 : (Authentication Server, AS) / (Ticket Granting Service, TGS) / (Service Server, SS)

AS는 TGS의 비밀키 공유, TGS는 SS의 비밀키를 공유

1. 클라이언트가 아래 메시지를 AS로 전송
   * User ID (암호화 되지않은 일반 텍스트)
2. AS는 User ID가 DB에 존재하는지 찾아본 후 존재하는 경우 아래 두 메시지를 리턴
   * encrypt(key: 클라이언트 PW기반 비밀키, data: “TGS 세션키”)
   * 티켓을 발급받을 수 있는 티켓(Ticket-Granting-Ticket, TGT) = encrypt(TGS 비밀키, “Client ID, 주소, 유효기간, TGS 세션 키”)
3. 클라이언트는 아래 두 메시지를 TGS로 전송 (TGS 세션키는 수신한 메시지를 복호화해서 획득)
   * Authenticator = encrypt(key: TGS 세션키, data: “Client ID, timestamp”)
   * TGT
4. TGS는 전달받은 TGT(TGS 비밀키로 복호화 가능), 암호화된 Authenticator (TGS 세션키로 복호화 가능)를 모두 복호화 해서 안에 담긴 Client ID가 일치하는지 확인하여 일치할 경우 아래 두 메시지를 리턴
   * encrypt(key: TGS 세션키, data: SS 세션키)
   * Ticket = encrypt(key: SS 비밀키, data: “Client ID, 주소, 유효기간, SS 세션키”)
5. 클라이언트는 아래 두 메시지를 SS로 전송
   * Authenticator = encrypt(key: SS 세션키, data: “Client ID, timestamp”)
   * Ticket(SGT)
6. SS는 전달받은 Ticket, Authenticator를 복호화 해서 안에 담긴 Client ID일치 확인 후 일치할 경우 아래 메시지를 리턴
   * encrypt(key: SS 세션키, data:Authenticator안에 담겨있던 timestamp)
7. 클라이언트는 전달받은 timestamp와 자신이 Authenticator에 담아보냈던 timestamp의 값이 일치하는 확인 후, 일치할경우 실제 작업을 시작한다.  

TGT : AS에서 발급, 로그인 세션 당 1번 발급

SGT : TGS에서 발급, 주어진 시간 동안 사용가능

---







