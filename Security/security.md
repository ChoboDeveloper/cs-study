# 정보보안



### 전자우편 보안

* 기밀성, 인증, 무결성, 부인방지를 제공한다.

* 대표적으로 PGP, PEM, S/MIME 등이 있다.

* PGP(Pretty Good Privacy)

  * 구현이 용이해 가장 널리 사용되고 있고 다양한 플랫폼에서 사용가능하다.

  * | 기능                  | 알고리즘                         | 설명                                                         |
    | :-------------------- | :------------------------------- | :----------------------------------------------------------- |
    | 기밀성(메시지 암호화) | Triple-DES,IDEA, CAST, RSA       | 송신자가 생성한 일회용 세션키로 알고리즘을 이용해 메시지 암호화.<br>수신자의 공개키로 RSA를 이용해서 세션키를 암호화하고 메시지에 첨부. |
    | 인증(전자 서명)       | RSA, DSS, SHA-1, MD5, RIPEMD-160 | 해시 알고리즘을 이용해서 메시지 다이제스트를 생성.<br>메시지 다이제스트는 송신자의 개인키로 DSS나 RSA를 이용해서 암호화한 후 메시지에 첨부한다. |
    | 압축                  | ZIP                              | ZIP으로 메시지를 압축한다.                                   |
    | 호환성                | Radix-64 변환                    | Radix-64 변환을 이용해 ASCII 부호로 변환한다.                |

* S/MIME(Secure Multipurpose Internet Mail Extensions)

  *  S/MIME은 기존 전자 우편 보안 시스템의 문제점인 PEM 구현의 복잡성과, PGP의 낮은 보안성과 기존 시스템과의 통합이 용이하지 않다는 점을 보안하기 위해 개발된 우편 보안 시스템이다.
  *  enveloped Data는 수신자의 공개키로 세션키를 암호화하고 메시지를 세션키로 암호화하여 보낸다. 수신자는 개인키로 세션키를 얻고 이를 통해 메시지를 복원할 수 있다.
  *  서명 및 봉인된 데이터(Signed-and-enveloped Data)란 송신자가 MIME 메시지를 암호화하고, 암호화된 MIME 메시지에 송신자 자신의 개인키(private key)를 이용하여 전자서명한 데이터를 의미한다.
  *  enveloped Data는 서명될 수 있고, signed Data는 암호화될 수 있다.

---

### 메시지 다이제스트

통신상의 메시지 무결성을 위해 해시 함수를 이용하여 크기를 고정한 검증 값

#### MAC(Message Authentication Code) 

> 키와 해시 함수를 이용해 생성한 코드

* 송신자와 수신자가 메세지를 공유 비밀키를 통해 MAC 값을 비교함으로써 무결성, 송신자 검증 가능
* SSL, IPSec 등에서 사용

#### MDC(Message Digest Code) 

>  키 없이 해시 함수만으로 생성한 코드

* 메시지의 해시값을 비교하여 무결성 검증
* 송신자가 누구인지 증명 X, 이를 해결하기 위해 MAC 사용

---

### 디지털 포렌식

1. 정당성의 원칙

획득한 증거 자료가 적법한 절차를 준수해야 하며, 위법한 방법으로 수집된 증거는 법적 효력을 상실한다.

2. 무결성의 원칙

수집 증거가 위/변조되지 않았음을 증명할 수 있어야 한다.

3. 재현의 원칙

같은 조건과 상황에서 항상 같은 결과가 나오도록 재현할 수 있어야 하고, 수행할 때마다 다른 결과가 나온다면 증거로 제시할 수 없다.

4. 신속성의 원칙

휘발성 증거의 수집 여부는 신속한 조치에 의해 결정되므로 모든 과정은 지체없이 진행되어야한다.

 5. 관리 연속성의 원칙

증거물 획득 -> 이송 -> 분석 -> 보관 -> 법정 제출의 각 단계에서 담당자 및 책임자를 명확히 해야한다.

---



### 무선랜 보안기법

#### WPA/WPA - Enterprise

* WPA-PSK가 기존 WEP의 암·복호화 키 관리 방식을 중점적으로 보완한 방식인데 비해서 WPA-Enterprise는 사용자 인증영역까지 보완한 방식
*  EAP 인증 프로토콜을 채택
* 즉, WPA/WPA2 의 PSK 버전은 사용자 인증을 거치지 않고 WEP 처럼 AP 와 사용자가 같은 Key를 공유하고, 그 키를 보호함으로써 이루어지는 방식인데 반해, EAP(Enterprise) 버전은 사용자 인증을 거치게 함으로써(EAP 인증 프로토콜) 더 안전하게 통신할 수 있는 것이다. 하지만 이러한 인증 담당할 서버를 따로 구성하여야만 WPA/WPA2-EAP 를 이용할 수 있으므로 보통 대규모 기업이나 보안이 중요한 곳에서 사용한다.



---

### CC

 국가마다 서로 다른 정보보호시스템 평가기준을 연동하고 평가결과를 상호 인증하기 위해 제정된 정보보안 평가기준

- ISO/IEC 15408 국제 표준

* CC인증의 평가보증등급

| 등급 | 주요내용       | 산출물                       |
| ----- | ------------------ | ---------------------------- |
| EAL1  | 기능 시험          | 기능 명세서, 설명서          |
| EAL 2 | 구조 시험          | 기본설계서, 기능시험서       |
| EAL 3 | 체계적 시험        | 생명주기, 개발보안, 오용분석 |
| EAL 4 | 설계 시험/검토     | 상세설계, 보안정책, 상세시험 |
| EAL 5 | 준정형화 설계/시험 | 개발문서, 보안기능 전체코드  |
| EAL 6 | 준정형화 설계 검증 | 전체 소스 코드               |
| EAL 7 | 정형화 설계 검증   | 개발 문서 정형화 기술        |

---
### 위험관리

> **위험**이란?  원하지 않는 사건이 발생하여 손실 또는 부정적인 영향을 미칠 가능성을 의미한다.
>
> (발생 가능성 * 손실의 정도)

### 위험의 구성요소

* **자산**(Assets): 조직이 사용하고 있는 네트워크 및 시스템을 구성하고 있는 모든 요소

* **위협**(Threats): 자산에 손실을 초래할 수 있는 사건의 잠재적 원인이나 행위자 (환경적, 의도적, 우연적 위협이 존재)

* **취약점**(Vernerability): 자산의 잠재적인 속성으로서 위협의 이용대상

<br>

### 위험분석

> 보호되어야 할 대상 정보 시스템과 조직의 위험을 측정하고 측정된 위험이 허용 가능한 수준인지 아닌지 판단할 수 있는 근거를 제공하는 것이다.

* **기준 접근법**
  * 표준화된 보안대책을 **체크리스트** 형태로 제공한다.
  * 조직화된 위험 평가 접근법을 구현할만한 자원을 갖지 못한 작은 조직에 사용하도록 권고되는 것이 일반적이다.
  * 위험분석을 위한 **자원이 필요하지 않다**.
* **비 정형화된 접근법**
  * 개인의 지식과 전문성을 활용하여 실용적인 위험 분석을 실시한다. (전문가 의존)
  * 중소규모의 조직에 적합하다.
* **상세 위험 분석**
  * 모든 정보자산에 대해 상세 위험 분석을 하는 방법이다.
    * 자산 분석: 조직의 자산 규모 파악, 자산의 가치 및 중요도 산출, 자산과 업무처리와의 관계 파악
    * 위협 분석: 자산에 피해를 가할 수 있는 잠재적 위협 파악, 위협이 발생할 가능성
    * 취약점 분석: 자산의 속성과 중요도를 바탕으로 자산이 가지고 있는 취약점 식별 및 취약점이 전체적인 위험에 미칠 수 있는 영향
    * 대응책 분석: 네트워크 및 시스템을 새로 구축하거나 운영 중인 자산에 필요한 대응책 조사 후 기본 기능 수행 여부를 파악
    * 위험 평가: 자산, 위협, 취약점, 대응책 분석을 통해 결과를 바탕으로 위험을 측정하고 평가한 후 대응책을 제시
    * 잔류 위험 평가: 위험 평가에서 대응책을 적용할 때 보안 정책에 명시되어 있는 허용 위험 수준을 만족하는지 검증
* **통합된 접근법**
  * **고위험 영역은 상세 위험 분석**을 사용하고 다른 영역은 **베이스라인 접근법**을 사용하는 방식이다.
  * 중요한 자원이 투입되기 전에 필요한 정보를 얻기 위한 간단한 고수준 접근을 사용한다.

<br>

### 위험 처리 전략

* 위험수용 : 현재의 위험을 받아들이고 잠재적 손실 비용을 감수하는 것이다.
* 위험감소 : 위험 발생 가능성, 위험 결과를 낮추는 방법
* 위험전가 : 위험에 대한 책임을 제3자와 공유하는 것이다(보험)
* 위험회피 : 위험이 존재하는 프로세스나 사업을 수행하지 않고 포기하는 것이다.

<br>

### 위험분석 방법론

* **정성적 분석방법(Qualitative)** : 위험을 매우높은, 높은, 중간, 낮은 등으로 표현

  > 정보자산에 대한 수치화가 불필요하여 계산에 대한 시간과 노력이 적게 든다.
  >
  > 하지만 측정기준이 주관적이다.

  * 델파이법
    * 전문가 집단에게 설문조사를 실시해 의견을 정리하는 분석방법
  * 시나리오법
    * 어떤 사실도 기대대로 발생되지 않는다고 가정하고, 특정 시나리오를 통해 발생 가능한 위협의 결과로 순위를 매겨 도출
  * 순위결정법
    * 비교우위 순위 결정표에, 위험 항목의 서술적 순위를 결정하는 방식

* **정량적 분석방법(Quantitative)** : 위험을 손실액과 같은 숫자값으로 표현

  > 정보의 가치가 논리적으로 평가되어 위험관리 성능 평가가 용이
  >
  > 하지만 계산이 복잡하여 분석하는데 시간, 노력이 많이 든다.

  * 확률분포법, 의사결정 트리, 몬테카를로 시뮬레이션 등의 방법

___

### SSL 인증서

* Root 인증서는 세상 사람들이 모두 신뢰하기로 약속한 기관, 예를 들어 위에서 언급한 Geotrust 등의 기관에서 발행한 인증서가 된다. 이러한 인증서는 일반적으로 웹 브라우저 등에 미리 내장되어 있으며, 해당 인증서에 대응하는 공개 키 또한 인증서 내부에 포함되어 있다.
* Google CA와 같은 CA회사의 인증서는 이러한 Root 인증서에 요청하여 root 인증서의 개인키를 통해 암호화되어 신뢰성을 보장받는다. 따라서, **Google CA의 인증서의 내용물에 대한 해시 값을, Geotrust가 Geotrust의 비밀 키로 암호화 해준것일테니, Google CA 또한 신뢰할 수 있다.**
* 여기서 해시값은 인증서의 주요정보를 모아 SHA256등의 해쉬 알고리즘을 이용하여 해쉬를 수행하고, 이렇게 해서 나온 해시값을 인증서의 **Finger Print(지문)**이라고 한다. 이렇게 나온 해시값(Finger Print)을 발급자(issuer)(CA)의 개인키로 암호화한 값이 **서명값(Digital Signing)**이다.
* CA의 공개키로 서명값을 복호화했을 때 이러한 해시값의 비교를 통해 해당 인증서의 무결성을 검증할 수 있다.
* [참고자료]([154. [Security\] SSL과 인증서 구조 이해하기 : CA (Certificate Authority) 를 중심으로 : 네이버 블로그 (naver.com)](https://m.blog.naver.com/alice_k106/221468341565))

---

### PKI

* 구성 : 인증기관(CA), 등록대행기관(RA), Certificate Repository, 사용자
* Certificate Repository는 인증서 및 인증서 폐기 목록(CRL)을 보관한다.
* 사용자가 인증서를 RA에 신청하면 RA에서 신청자의 신분을 검증하여 해당 사용자의 인증서 발급을 CA에 요청하고, CA에서는 암호하 key 쌍(Public Key, Private Key)을 생성하여 개인키인 Private Key는 사용자에, Public Key를 포함한 인증서는 인증서 저장소(Certificate Repository)에 저장함



```
* 메시지에 서명하지 않고 메시지의 해시값과 같은 메시지 다이제스트에 서명하는 이유는 공개키 암호화에 따른 성능저하를 극복하기 위함이다.
```

---

### OCSP

Online Certificate Status Protocol

* OCSP는 RFC2560에서 소개되었으며 목적은 인증서의 상태를 실시간으로 체크하기 위한 프로토콜이다.
* OCSP는 인증서의 시리얼을 통하여 실시간으로 인증서의 만료여부를 CA 인증서 DB에 직접 요청하여 실시간으로 인증서의 만료여부를 확인 할 수 있으며 CRL과 같이 불필요한 목록을 모두 받아 볼 필요가 없어 그 속도가 비교적 빠르다.

---

### 의사 난수

* 무작위성 :  비트 수의 출현 빈도가 동일해야한다. 즉, 특정 분포를 보여서는 안된다.
* 비예측성 : 수열의 잇따른 다음 수의 순서에 대해 예측이 불가능해야한다.
* 약한 의사 난수는 무작위성만을 가지고, 강한 의사 난수는 비 예측성을 포함한다. 이러한 비예측성을 생성하기 위해 비결정적 알고리즘이 사용될 수 있다.
* True Random Number은 재현불가능성을 포함한다. 컴퓨터는 유한 오토마타이고 결국 시드값을 통해 난수를 생성하기 때문에 True Random Number를 구현하기 어렵다.

---

### 커버로스

구성요소 : (Authentication Server, AS) / (Ticket Granting Service, TGS) / (Service Server, SS)

AS는 TGS의 비밀키 공유, TGS는 SS의 비밀키를 공유

1. 클라이언트가 아래 메시지를 AS로 전송
   * User ID (암호화 되지않은 일반 텍스트)
2. AS는 User ID가 DB에 존재하는지 찾아본 후 존재하는 경우 아래 두 메시지를 리턴
   * encrypt(key: 클라이언트 PW기반 비밀키, data: “TGS 세션키”)
   * 티켓을 발급받을 수 있는 티켓(Ticket-Granting-Ticket, TGT) = encrypt(TGS 비밀키, “Client ID, 주소, 유효기간, TGS 세션 키”)
3. 클라이언트는 아래 두 메시지를 TGS로 전송 (TGS 세션키는 수신한 메시지를 복호화해서 획득)
   * Authenticator = encrypt(key: TGS 세션키, data: “Client ID, timestamp”)
   * TGT
4. TGS는 전달받은 TGT(TGS 비밀키로 복호화 가능), 암호화된 Authenticator (TGS 세션키로 복호화 가능)를 모두 복호화 해서 안에 담긴 Client ID가 일치하는지 확인하여 일치할 경우 아래 두 메시지를 리턴
   * encrypt(key: TGS 세션키, data: SS 세션키)
   * Ticket = encrypt(key: SS 비밀키, data: “Client ID, 주소, 유효기간, SS 세션키”)
5. 클라이언트는 아래 두 메시지를 SS로 전송
   * Authenticator = encrypt(key: SS 세션키, data: “Client ID, timestamp”)
   * Ticket(SGT)
6. SS는 전달받은 Ticket, Authenticator를 복호화 해서 안에 담긴 Client ID일치 확인 후 일치할 경우 아래 메시지를 리턴
   * encrypt(key: SS 세션키, data:Authenticator안에 담겨있던 timestamp)
7. 클라이언트는 전달받은 timestamp와 자신이 Authenticator에 담아보냈던 timestamp의 값이 일치하는 확인 후, 일치할경우 실제 작업을 시작한다.  

TGT : AS에서 발급, 로그인 세션 당 1번 발급

SGT : TGS에서 발급, 주어진 시간 동안 사용가능

---

### IPSEC

네트워크 계층에서 인증, 기밀성, 키 관리 기능을 제공

* AH(Authentication Header)
  * 정보의 **인증**, **무결성**을 제공한다.
* ESP(Encapsulation Security Payload)
  * IP 페이로드를 암호화하여 **기밀성**을 제공함으로써 제3자에게 데이터가 노출되는 것을 차단한다.
* IKE(Internet key Exchange)
  * 키 교환에 사용되는 프로토콜이며 UDP 500 포트를 사용
  * 두 컴퓨터 간의 보안 연결 설정을 위해 사용된다.
* 전송모드
  * 헤더와 페이로드 사이에 AH/ESP가 위치한다.
* 터널모드
  * 전체 패킷 앞에 AH/ESP가 위치하고 새로운 IP헤더로 데이터를 감싼다.

참고) 2계층에서 터널링 = PPTP, L2TP, L2F / 3계층에서 터널링 = IPsec

---

### 시스템보안

[시스템 보안 (velog.io)](https://velog.io/@woobuntu/시스템-보안#시스템-보안)

> 권한이 없는(허가받지 않은) 사용자가 파일이나 폴더, 장치 등을 사용하지 못하게 제한하여 시스템을 보호하는 기능

**계정 관리**

* 적절한 권한을 가진 사용자를 식별하기 위한 인증 관리

**세션 관리**

* 세션에 대한 지속적인 인증

**접근 제어**

**권한 관리**

**로그 관리**

* 시스템 사용자가 로그인 후 명령을 내리는 과정에 대한 시스템의 동작 구분

**취약점 관리**

---

### 접근통제 기법

> **자원에 대한 비인가된 접근을 감시하고, 접근을 요구하는 이용자를 식별하는 관리방법**
>
> **물리적통제 : 물리적 환경에 대한 통제 장치**
>
> **논리적통제 : 시스템내 변조 또는 조작 방지**

* 접근통제원칙

  * 직무분리의 원칙 : 업무의 발생, 승인, 변경, 확인, 배포 등이 모두 한사람에 의해 처음부터 끝까지 처리 될 수 없도록 하는 강제적인 보안 정책
  * 최소권한의 원칙 : 허가 받은 일을 수행하기 위해서, 최소한의 권한만 부여

* Reference Monitor

  > 보안커널의 가장 중요한 부분으로 접근통제 결정을 중재하는 OS의 요소(객체에 대한 접근을 제어하는 역할을 담당)

  * 주체가 객체에 접근하기 위해 System Call 시, 가령 write() reference monitor는 이를 감시한다. 이러한 통제를 하기 위해 Reference Monitor안에는 주체와 객체의 접근 권한을 정의한 DB가 같이 있음. (주체 : 프로세스, 객체 : 파일)
  * 참조 모니터의 3가지 요소
    * Completeness : 완전성, 우회 불가능, invoke(complete mediation)
    * Isolation : 격리성, tamper proof(부정조작 불가능)
    * Verifiability : 검증가능성, 분석하고 테스트할 정도로 충분히 작아야함(simple, small, understandable, testable)

* 접근통제의 3단계

  * 식별 : 식별은 시스템에게 주체의 식별자를 요청하는 과정으로 각 시스템의 사용자들은 시스템이 식별할 수 있는 유일한 식별자(ID)를 갖는다.
  * 인증 : 임의의 정보에 접근할 수 있는 주체의 능력이나 주체의 자격을 검증
    * Password, OTP, 인증서 등
  * 인가 : 사용자, 프로그램, 프로세스에게 허가한 권한을 의미
    * 여기서 접근 통제 정책에 따라 MAC, DAC, RBAC 등으로 분류

<br>

### MAC 보안모델

**벨라파듈라 모델**

> **기밀성**을 보장하는 최초의 수학적 모델로 강제적 정책에 의해 접근 통제하는 모델

* 단순 보안 속성(No Read Up): 주체는 같거나 낮은 계층만 읽을 수 있다
* 성형 보안 속성(No write Down): 주체는 같거나 높은 계층만 쓸 수 있다.
* 특수 속성 규칙(Strong star property rule): 주체는 동일레벨에서 읽기 쓰기가 가능하다.

**비바 무결성 모델**

> **무결성**을 위한 최초의 상업적 모델

* 상위레벨 쓰기 금지

* 하위레벨 읽기 금지

* 호출 속성: 높은 무결성을 가진 주체에게 서비스를 요청할 수없다. (낮은 무결성을 가진 객체에게 요청 가능)

**클락-윌슨 무결성 모델**

> 무결성 중심의 상업적 모델

* 사용자가 직접 객체에 접근할 수 없고 프로그램을 통해서만 객체에 접근할 수 있게 하는 보안 모델이다.

**만리장성 모델**

* 사용자의 이전 동작에 따라 변화할 수 있는 접근 통제를 제공한다. (MAC, DAC)

<br>

### DAC 보안모델

**접근제어 행렬**

* 주체를 행(Row) 객체를 열(Calumn)로 구성하고 주체가 객체에 수행할 수 있는 접근 권한을 기록하여 관리한다.

* 비어있는 셀이 많아지므로 공간적으로 비효율적이다.

**자격 목록**

* 한 주체가 갖는 자격들의 리스트이다. 자격 리스트는 행 단위로 관리된다.
* 콘텐츠의 보안성이 보장받지 못하는 분산환경에서 사용하기에 적합하다.
* 대표적인 예로는 커버로스가 있다.

**접근제어 목록**

* 객체의 관점에서 객체에 어떤 주체가 어떤 접근 권한을 갖는지 명시하는 것이다.

```
접근제어 행렬은 행렬로 접근제어 설정
자격 목록은 파일에 권한을 부여하고 사용자가 파일의 권한에 따라서 접근
접근제어 목록은 사용자에 권한을 부여하고 사용자가 권한에 따라 파일에 접근
```



---

### IDS

> 침입 감지 시스템

**오용탐지**

* 악성패킷 등을 분석한 **침입 패턴**(Rule Set)을 저장하여 패턴과 동일하면 탐지
* 오탐율(False Positive)이 낮지만, 미탐율(False Negative)가 높음
* 제로데이 공격(Zero-day Attack)을 탐지할 수 없으며, 오용탐지를 **시그니처(Signature) 기반 혹은 지식(Knowledge) 기반**의 탐지 방법이라고 부른다.

**이상탐지**

* **정상 패턴**을 저장하고 이와 다르면 탐지하는 방식
* 오탐율이 높지만, 미탐율이 낮음
* 제로데이 공격에 대응

___



### 테스트 기법

#### Fuzzing

> 임의로 발생시킨 데이터를 프로그램의 입력으로 사용하여 소프트웨어의 안전성 및 취약성 등을 검사하는 방법

* 블랙박스 검사 방법론

---

### DMZ

>  DMZ란 내·외부 네트워크 구간 사이에 위치한 중간지점으로, 침입차단시스템 등으로 접근 제한 등을 수행하지만 외부 네트워크에서 직접 접근이 가능한 영역

* DMZ 내에는 웹, DNS, 메일 서버 등이 위치할 수 있음
* 내부 방화벽과 외부 방화벽 사이에 위치할 수 있음

---

### OWASP

| OWASP 2013                                                   | OWASP 2017                                                  |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| 1. Injection                                                 | 1. Injection                                                |
| 2. 취약한 인증 및 세션관리(Broken Authentication and Session Management) | 2. 취약한 인증(Broken Authentication)                       |
| 3. XSS                                                       | 3. 민감 데이터 노출(Sensitive Data Exposure)                |
| 4. 취약한 개체 직접 참조(Insecure Direct Object References)  | 4. XML External Entities (XXE)                              |
| 5. 보안 설정 오류(Security Misconfiguration)                 | 5. 취약한 접근 통제(Broken Access control) / (13년도의 4+7) |
| 6. 민감 데이터 노출(Sensitive Data Exposure)                 | 6. 잘못된 보안 구성                                         |
| 7. 접근 통제 누락(Missing Function Level Access Control)     | 7. XSS                                                      |
| 8. CSRF                                                      | 8. 안전하지 않은 역직렬화                                   |
| 10. 검증되지 않은 리다이렉트, 포워드                         | 9. 알려진 취약점이 있는 구성요소 사용(13년도랑 같음)        |

---



 

